<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>DeepRead AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Overall layout */
        body {
            margin: 0;
            font-family: 'Lexend', sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: white;
            /* off-white */
            color: #000000;
            font-weight: 400;
            text-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: 'Lexend', sans-serif;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        }

        button {
            font-family: 'Lexend', sans-serif;
            font-weight: 500;
            text-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.15);
        }

        input,
        textarea,
        select {
            font-family: 'Lexend', sans-serif;
            font-weight: 400;
        }

        #chatButton {
            position: fixed;
            bottom: 20px;
            right: 60px;
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: #800020;
            color: #ffffff;
            border-radius: 8px;
            padding: 0 24px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(128, 0, 32, 0.3);
            z-index: 1000;
            white-space: nowrap;
            font-size: 14px;
            height: 40px;
            line-height: 40px;
            opacity: 1;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        #chatButton.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        #chatButton .material-icons {
            font-size: 20px;
            line-height: 1;
            position: relative;
            top: -1px;
        }

        .user-message,
        .ai-message,
        .system-message {
            font-family: 'Lexend', sans-serif;
            font-weight: 400;
            text-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1);
            color: #ffffff;
        }

        #sidebar .conversation-item {
            font-family: 'Lexend', sans-serif;
            font-weight: 400;
            text-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1);
            color: black;
        }

        .annotation-item {
            font-family: 'Lexend', sans-serif;
            font-weight: 400;
            text-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1);
            color: #ffffff;
        }

        /* Sidebar styling */
        #sidebar {
            width: 250px;
            min-width: 250px;
            background-color: #f5f5f5;
            border-right: 1px solid #f5f5f5;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        #sidebar.closed {
            transform: translateX(-100%);
        }

        #sidebar .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        #sidebar .conversation-item {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            display: block;
            background-color: rgba(255, 255, 255, 0.9);
            margin-bottom: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #sidebar .conversation-item:hover {
            background-color: #47a8e8;
        }

        #sidebar .conversation-item span {
            display: block;
            margin-bottom: 5px;
        }

        #sidebar .conversation-item button {
            float: right;
        }

        /* Main content area */
        #content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: calc(100% - 250px);
            margin-left: 0;
            transition: all 0.3s ease;
            position: relative;
        }

        #sidebar.closed+#openSidebar+#content {
            width: 100%;
            margin-left: -250px;
        }

        #topbar {
            background-color: #f5f5f5;
            /* off-white */
            padding: 16px 24px;
            border-bottom: 1px solid #f5f5f5;
            display: flex;
            align-items: center;
            color: #000000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }

        #topbar .left-section {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            z-index: 0;
            pointer-events: none;
        }

        #topbar h1 {
            flex-grow: 1;
            margin: 0;
            font-size: 1.2em;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            text-align: center;
            padding: 10px 0;
        }

        #topbar .brand-name {
            pointer-events: auto;
        }

        /* Upload form in topbar */
        #uploadForm {
            margin-left: auto;
            z-index: 1;
            display: flex;
            gap: 10px;
            align-items: center;
            min-width: fit-content;
            margin-right: 10px;
        }

        #main {
            flex-grow: 1;
            display: flex;
            overflow: hidden;
        }

        /* Left panel: PDF viewer using PDF.js */
        #left-panel {
            flex-grow: 1;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #pdfViewer {
            position: relative;
            transform-origin: top center;
            transition: transform 0.2s ease;
        }

        /* Add zoom controls */
        #zoomControls {
            display: none;
            /* Hide by default */
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: white;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 100;
        }

        #zoomControls.no-paper {
            display: none !important;
        }

        #zoomControls button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            padding: 0;
        }

        #zoomControls span {
            display: flex;
            align-items: center;
            padding: 0 8px;
            color: #000000;
            font-weight: 500;
            min-width: 60px;
            justify-content: center;
        }

        .pdf-page {
            position: relative;
            margin-bottom: 20px;
        }

        /* Update annotation marker style */
        .annotation-marker {
            position: absolute;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            padding: 2px 4px;
        }

        .annotation-marker.note {
            background: rgba(26, 54, 93, 0.3);
        }

        .annotation-marker.note:hover {
            background: rgba(26, 54, 93, 0.5);
        }

        .annotation-marker.question {
            background: rgba(128, 0, 32, 0.3);
            /* #800020 with 0.3 opacity */
        }

        .annotation-marker.question:hover {
            background: rgba(128, 0, 32, 0.5);
            /* #800020 with 0.5 opacity */
        }

        /* Right panel: Extraction data & annotations list */
        #right-panel {
            width: 300px;
            padding: 20px;
            /* border-left: 3px solid #47a8e8;
            background-color: #47a8e8; */
            overflow-y: auto;
            /* border-top-left-radius: 12px;
            border-bottom-left-radius: 12px; */
            position: relative;
            padding-bottom: 20px;
        }

        #annotationList {
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }

        .annotation-item {
            padding: 16px;
            margin-bottom: 20px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 2px 6px 2px rgba(60, 64, 67, 0.15);
            font-size: 13px;
            line-height: 1.5;
            position: relative;
        }

        .annotation-item::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 12px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid white;
        }

        .annotation-item .selected-text {
            color: #000000;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #dadce0;
            font-style: italic;
        }

        .annotation-item .comment {
            color: #000000;
            margin-bottom: 12px;
        }

        .annotation-item .metadata {
            color: #000000;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .annotation-item .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 12px;
        }

        .annotation-item button {
            flex: 1;
            min-width: calc(50% - 3px);
            font-size: 11px;
            padding: 6px 8px;
            border-radius: 4px;
            background-color: #f1f3f4;
            color: #000000;
            border: 1px solid #dadce0;
            box-shadow: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .annotation-item button .material-icons {
            font-size: 14px;
            margin-right: 4px;
        }

        /* Annotation Modal styling */
        #annotationModal {
            display: none;
            position: fixed;
            z-index: 1100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        #annotationModalContent {
            background-color: #fff;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 400px;
            max-width: 90%;
            position: relative;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        #annotationModalContent textarea {
            width: 100%;
            height: 80px;
            border-radius: 8px;
            border: 1px solid #47a8e8;
            padding: 8px;
            transition: border 0.2s ease;
        }

        #annotationModalContent textarea:focus {
            outline: none;
            border-color: rgba(178, 103, 94, 0.5);
        }

        #annotationModalContent button {
            margin-top: 10px;
        }

        /* Button to open sidebar when closed */
        #openSidebar {
            display: none;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1100;
        }

        /* Selection popup menu */
        #selectionPopup {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #f5f5f5;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 8px;
            z-index: 1000;
        }

        /* Add styles for PDF.js text layer */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
        }

        .textLayer>span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: rgb(180, 0, 170);
            border-radius: 4px;
        }

        .textLayer .highlight.selected {
            background-color: rgb(0, 100, 0);
        }

        /* Loading overlay */
        .loading-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            backdrop-filter: blur(4px);
        }

        .loading-spinner {
            border: 5px solid #f5f5f5;
            /* off-white */
            border-radius: 50%;
            border-top: 5px solid #47a8e8;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 12px rgba(51, 241, 189, 0.3);
        }

        .loading-text {
            color: white;
            margin-top: 10px;
            font-size: 1.2em;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        button {
            background-color: #1a365d;
            color: #ffffff;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background-color: #2c4f82;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        .user-message,
        .ai-message,
        .system-message {
            padding: 12px 16px;
            margin: 8px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .user-message {
            background-color: #1a365d;
            color: #ffffff;
            border-bottom-right-radius: 4px;
        }

        .ai-message {
            background-color: #f5f5f5;
            /* off-white */
            color: #000000;
            border-bottom-left-radius: 4px;
        }

        .system-message {
            background-color: #1a365d;
            color: #ffffff;
            padding: 8px;
            margin: 5px;
            border-radius: 8px;
            max-width: 80%;
            align-self: center;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Add this style */
        #uploadPrompt {
            display: none;
            /* Hidden by default */
            text-align: center;
            padding: 20px;
        }

        .custom-file-upload {
            display: inline-flex;
            align-items: center;
            padding: 8px 12px;
            background-color: #1a365d;
            color: #ffffff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            height: 36px;
            box-sizing: border-box;
            white-space: nowrap;
            min-width: fit-content;
        }

        .custom-file-upload:hover {
            background-color: #2c4f82;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        .custom-file-upload .material-icons {
            margin-right: 8px;
            font-size: 18px;
        }

        input[type="file"] {
            display: none;
        }

        #uploadForm button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            height: 36px;
            padding: 8px 12px;
            box-sizing: border-box;
        }

        #uploadForm button .material-icons {
            font-size: 18px;
        }

        /* Add these styles */
        .custom-file-upload.file-selected {
            background-color: #1a365d;
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

        .file-name-display {
            font-size: 0.9em;
            color: black;
            margin-left: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 1;
        }

        .file-name-display.visible {
            opacity: 1;
        }

        /* Add this style */
        .disclaimer {
            position: fixed;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            color: #1f1e1d;
            opacity: 0.7;
            text-align: center;
            font-family: 'Lexend', sans-serif;
            text-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1);
            z-index: 100;
            pointer-events: none;
        }

        /* Update annotation item style for different types */
        .annotation-item.note::before {
            border-right-color: #1a365d;
        }

        .annotation-item.question::before {
            border-right-color: #800020;
        }

        .annotation-item.note {
            border-left: 3px solid #1a365d;
        }

        .annotation-item.question {
            border-left: 3px solid #800020;
        }

        .ai-response-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 24px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
        }

        .ai-response-modal .content {
            overflow-y: auto;
            padding: 16px;
            margin: 16px 0;
            background: #f8f9fa;
            border-radius: 8px;
            font-family: 'Lexend', sans-serif;
            line-height: 1.6;
            color: #333;
        }

        /* Response Section Styling */
        .response-section {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e0e0e0;
        }

        .response-section:last-child {
            border-bottom: none;
        }

        .response-section h3 {
            color: #1a365d;
            font-size: 1.1em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Citation Styling */
        .web-citation {
            background: #f0f7ff;
            border-left: 3px solid #47a8e8;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .web-citation a {
            color: #2c5282;
            text-decoration: none;
            font-weight: 500;
        }

        .web-citation a:hover {
            text-decoration: underline;
        }

        /* Paper Citation Styling */
        .paper-citation {
            background: #fff5f5;
            border-left: 3px solid #800020;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 0.9em;
        }

        /* Section Icons */
        .section-icon {
            font-size: 18px !important;
            opacity: 0.8;
        }

        /* Loading State */
        .ai-response-loading {
            text-align: center;
            padding: 20px;
        }

        .ai-response-loading .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #47a8e8;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }

        /* Chat Interface Styling */
        #chatInterface {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 600px;
            background: white;
            border: none;
            border-radius: 16px;
            z-index: 1000;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
            flex-direction: column;
            transition: all 0.3s ease;
            transform-origin: bottom right;
            transform: scale(0);
            opacity: 0;
            overflow: hidden;
            display: flex;
        }

        #chatInterface.visible {
            transform: scale(1);
            opacity: 1;
            display: flex;
        }

        #chatInterface .chat-header {
            padding: 16px;
            border-bottom: 1px solid #e0dbdb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #800020;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            gap: 12px;
        }

        #chatInterface .chat-header h3 {
            margin: 0;
            color: white;
        }

        #chatInterface .chat-header .header-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #chatInterface #closeChatButton {
            background: transparent;
            color: white;
            border: none;
            font-size: 24px;
            padding: 0;
            box-shadow: none;
        }

        #chatInterface #closeChatButton:hover {
            background: transparent;
            color: #e0dbdb;
        }

        #chatMessages {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: #f7f7f8;
        }

        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }

        #chatMessages::-webkit-scrollbar-track {
            background: #f7f7f8;
        }

        #chatMessages::-webkit-scrollbar-thumb {
            background-color: #1a365d;
            border-radius: 4px;
            border: 2px solid #f7f7f8;
        }

        .chat-message {
            max-width: 88%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.5;
            font-size: 14px;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .user-message {
            background-color: #1a365d;
            color: #ffffff;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .ai-message {
            background-color: #800020;
            /* off-white */
            color: #ffffff;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .system-message {
            background-color: #1a365d;
            color: #ffffff;
            align-self: center;
            font-size: 12px;
            padding: 8px 12px;
        }

        .chat-input-container {
            flex: 0 0 auto;
            padding: 16px;
            border-top: 1px solid #e0dbdb;
            background: white;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        #chatInput {
            width: 100%;
            min-height: 48px;
            max-height: 150px;
            padding: 12px;
            border: 1px solid #e0dbdb;
            border-radius: 8px;
            resize: none;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 8px;
            box-shadow: 0 0 0 2px transparent;
            transition: border-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
            overflow-y: auto;
            scrollbar-width: thin;
            /* For Firefox */
            scrollbar-color: #47a8e8 white;
            /* For Firefox */
        }

        #chatInput::-webkit-scrollbar {
            width: 8px;
        }

        #chatInput::-webkit-scrollbar-track {
            background: white;
        }

        #chatInput::-webkit-scrollbar-thumb {
            background-color: #1a365d;
            border-radius: 4px;
            border: 2px solid white;
        }

        #sendChatButton {
            width: 100%;
            padding: 10px;
            background-color: #800020;
            color: #ffffff;
            font-weight: 600;
        }

        #sendChatButton:disabled {
            background-color: #e0dbdb;
            cursor: not-allowed;
        }

        /* Add styles for the clear chat button */
        #clearChatButton {
            background: transparent;
            color: white;
            border: none;
            font-size: 14px;
            padding: 4px 8px;
            box-shadow: none;
            display: flex;
            align-items: center;
            gap: 4px;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        #clearChatButton:hover {
            background: transparent;
            opacity: 1;
        }

        #clearChatButton .material-icons {
            font-size: 16px;
        }

        /* Add styles for code blocks within messages */
        .chat-message pre {
            max-width: 100%;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            scrollbar-width: thin;
            /* For Firefox */
            scrollbar-color: #47a8e8 transparent;
            /* For Firefox */
        }

        .chat-message pre::-webkit-scrollbar {
            height: 8px;
        }

        .chat-message pre::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-message pre::-webkit-scrollbar-thumb {
            background-color: #1a365d;
            border-radius: 4px;
        }

        .chat-message code {
            word-break: break-word;
            white-space: pre-wrap;
        }

        /* Welcome Panel Styles */
        #welcomePanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 32px;
            border-radius: 16px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
            max-width: 600px;
            width: 90%;
            z-index: 1000;
        }

        #welcomePanel h2 {
            color: #000000;
            margin-top: 0;
            margin-bottom: 24px;
            text-align: center;
        }

        .step-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .step {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 16px;
            background: #f7f7f8;
            border-radius: 12px;
            transition: transform 0.2s ease;
        }

        .step:hover {
            transform: translateX(8px);
        }

        .step .step-number {
            background: #47a8e8;
            color: #f0e3dc;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            flex-shrink: 0;
        }

        .step .step-content {
            flex: 1;
        }

        .step h3 {
            margin: 0 0 8px 0;
            color: #000000;
        }

        .step p {
            margin: 0;
            color: #5f6368;
            line-height: 1.5;
        }

        /* Add these styles */
        #sidebar.no-paper,
        #right-panel.no-paper,
        #chatButton.no-paper {
            display: none !important;
        }

        #content.no-paper {
            margin-left: 0 !important;
            width: 100% !important;
        }

        #main.no-paper {
            justify-content: center;
            align-items: center;
        }

        /* Add these styles */
        .type-selector {
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid #47a8e8;
            background: white;
            color: #f0e3dc;
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .type-selector:hover {
            transform: translateY(-1px);
            opacity: 1;
        }

        .type-selector.selected {
            background: #47a8e8;
            color: white;
            opacity: 1;
        }

        .type-selector .material-icons {
            font-size: 20px;
        }

        /* Add new chat-specific loading styles */
        #chatInterface .loading-overlay {
            border-radius: 16px;
            /* Match chat interface border radius */
        }

        #chatInterface .loading-text {
            font-size: 1em;
            /* Smaller text for chat context */
        }

        /* Add new branding styles */
        .brand-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .brand-name {
            font-size: 30px;
            font-weight: 800;
            background: linear-gradient(135deg, #1a365d 0%, #47a8e8 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: transparent;
        }
    </style>
    <!-- Include PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js"></script>
    <!-- Add PDF.js text layer CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf_viewer.css">
    <!-- Add marked.js library in the head section -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
    <!-- Sidebar for conversation list -->
    <div id="sidebar">
        <div class="sidebar-header">
            <h3>Uploads</h3>
            <button id="closeSidebar">X</button>
        </div>
        <div id="conversationList"></div>
    </div>
    <button id="openSidebar">☰</button>

    <!-- Main Content Area -->
    <div id="content">
        <div id="topbar">
            <div class="left-section">
                <div class="brand-container">
                    <p class="brand-name">DeepRead AI</p>
                </div>
            </div>
            <form id="uploadForm" method="POST" enctype="multipart/form-data" action="/upload">
                <label class="custom-file-upload">
                    <input type="file" name="pdfFile" accept=".pdf" required />
                    <i class="material-icons">description</i>
                    <span class="label-text">Choose File</span>
                </label>
                <span class="file-name-display"></span>
                <button type="submit">
                    <i class="material-icons">upload</i>
                    Upload
                </button>
                <select id="aiProvider"
                    style="margin-left: 10px; padding: 8px 12px; border-radius: 8px; border: 0px solid #47a8e8; background: #47a8e8; color: black; height: 36px; box-sizing: border-box; cursor: pointer; font-family: 'Lexend', sans-serif; font-weight: 500; font-size: 13px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); transition: all 0.2s ease; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;utf8,<svg fill=\'black\' height=\'24\' viewBox=\'0 0 24 24\' width=\'24\' xmlns=\'http://www.w3.org/2000/svg\'><path d=\'M7 10l5 5 5-5z\'/></svg>'); background-repeat: no-repeat; background-position: right 8px center; padding-right: 32px;">
                </select>
            </form>
        </div>
        <div id="main">
            <!-- Left panel: PDF viewer -->
            <div id="left-panel">
                <div id="uploadPrompt">
                    <h2>Upload a research paper to get started...</h2>
                </div>
                <div id="pdfViewer"></div>
            </div>
            <!-- Right panel: Extraction data and annotations list -->
            <div id="right-panel">
                <h3>Annotations</h3>
                <div id="annotationList"></div>
                <button id="chatButton">
                    <i class="material-icons">chat</i>
                    Chat with Paper
                </button>
            </div>
        </div>
    </div>

    <!-- Annotation Modal for PDF annotations -->
    <div id="annotationModal">
        <div id="annotationModalContent">
            <h3>Add Annotation</h3>
            <p id="annotationPreview" style="font-size:0.9em; color:#555; text-align: center;"></p>

            <!-- Add hidden select for compatibility -->
            <select id="annotationType" style="display: none;">
                <option value="note" selected>Note</option>
                <option value="question">Question</option>
            </select>

            <div style="display: flex; justify-content: center; gap: 16px; margin-bottom: 16px;">
                <button class="type-selector" data-type="note" onclick="selectAnnotationType('note')">
                    <i class="material-icons">note_add</i>
                    Note
                </button>
                <button class="type-selector" data-type="question" onclick="selectAnnotationType('question')">
                    <i class="material-icons">help_outline</i>
                    Question
                </button>
            </div>

            <div style="text-align: center;">
                <textarea id="annotationText" placeholder="Enter your comment"
                    style="width: 90%; margin: 0 auto;"></textarea>
            </div>

            <div style="text-align: center; margin-top: 16px;">
                <button id="saveAnnotation">Save Annotation</button>
                <button id="cancelAnnotation">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Add selection popup menu -->
    <div id="selectionPopup">
        <button id="addAnnotationBtn">Add annotation</button>
    </div>

    <div class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing...</div>
    </div>

    <!-- Chat Interface -->
    <div id="chatInterface">
        <div class="chat-header">
            <h3>Chat with Paper</h3>
            <div class="header-buttons">
                <button id="clearChatButton">
                    <i class="material-icons">delete_sweep</i>
                    Clear
                </button>
                <button id="closeChatButton">×</button>
            </div>
        </div>
        <div id="chatMessages"></div>
        <div class="loading-overlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">AI is thinking...</div>
        </div>
        <div class="chat-input-container">
            <textarea id="chatInput" placeholder="Ask a question about the paper..." rows="1"
                onInput="this.style.height = 'auto'; this.style.height = (this.scrollHeight) + 'px';"></textarea>
            <button id="sendChatButton">Send</button>
        </div>
    </div>

    <div class="disclaimer">
        This tool can make mistakes. Check important info.
    </div>

    <!-- Add this after the loading overlay -->
    <div id="welcomePanel">
        <h2>To get started...</h2>
        <div class="step-container">
            <div class="step">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h3>Upload Your Paper</h3>
                    <p>Start by uploading a PDF research paper using the upload button in the top bar.</p>
                </div>
            </div>
            <div class="step">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h3>Add Annotations</h3>
                    <p>Select text in the paper to add notes or questions. An AI model can verify your notes or answer
                        your questions about the selected content.</p>
                </div>
            </div>
            <div class="step">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h3>Chat with the Paper</h3>
                    <p>Use the chat feature to ask questions about any aspect of the paper. An AI model will provide
                        answers based on the paper's content and general knowledge.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this before the right panel div -->
    <div id="zoomControls">
        <button onclick="adjustZoom(-0.25)"><i class="material-icons">remove</i></button>
        <span id="zoomLevel">100%</span>
        <button onclick="adjustZoom(0.25)"><i class="material-icons">add</i></button>
    </div>

    <script>
        // Global variables for PDF rendering and conversation management.
        let pdfDoc = null;
        let currentAnnotations = []; // Annotations for the current PDF.
        let currentPdfUrl = "";
        let conversations = []; // Each conversation: { id, title, pdf_url, extraction, annotations }.
        let currentConversationId = null;
        let currentSelection = null;
        let currentChatHistory = [];
        let currentZoom = 1.5; // Starting zoom level (matches your existing scale)
        let initialZoom = 1.5; // Store initial zoom for reset reference

        // Load persistent conversations from the server on page load.
        async function loadPersistentConversations() {
            const res = await fetch("/conversations");
            conversations = await res.json();
            renderSidebar();
            if (conversations.length > 0) {
                loadConversation(conversations[0].id);
            }
        }

        // Persist the conversation list to the server.
        async function persistConversations() {
            await fetch("/conversations", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(conversations)
            });
        }

        // Render the PDF using PDF.js with annotation overlays.
        async function renderPDF(url, annotations) {
            currentPdfUrl = url;
            const viewer = document.getElementById('pdfViewer');
            viewer.innerHTML = "";
            pdfDoc = await pdfjsLib.getDocument(url).promise;

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: currentZoom });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.style.width = viewport.width + "px";
                pageDiv.style.height = viewport.height + "px";
                pageDiv.style.position = "relative";
                pageDiv.dataset.pageNumber = pageNum;

                // Canvas layer
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                pageDiv.appendChild(canvas);

                // Text layer
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'textLayer';
                textLayerDiv.style.width = viewport.width + "px";
                textLayerDiv.style.height = viewport.height + "px";
                pageDiv.appendChild(textLayerDiv);

                viewer.appendChild(pageDiv);

                // Render page content
                const context = canvas.getContext('2d');
                await page.render({ canvasContext: context, viewport: viewport }).promise;

                // Render text layer
                const textContent = await page.getTextContent();
                pdfjsLib.renderTextLayer({
                    textContent: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                });

                // Add event listener to text layer for selection
                textLayerDiv.addEventListener('mouseup', handleTextSelection);

                // Render existing annotation markers
                if (annotations) {
                    annotations.filter(a => a.page === pageNum).forEach(a => {
                        addAnnotationMarker(pageDiv, a);
                    });
                }
            }
            updateZoomDisplay();
        }

        // Update the addAnnotationMarker function to use selection coordinates
        function addAnnotationMarker(pageDiv, annotation) {
            const marker = document.createElement('div');
            marker.className = `annotation-marker ${annotation.type}`; // Add type class
            marker.style.left = annotation.x + "px";
            marker.style.top = annotation.y + "px";
            marker.style.width = annotation.width + "px";
            marker.style.height = annotation.height + "px";
            marker.dataset.annotationId = annotation.id;
            marker.title = annotation.comment;
            pageDiv.appendChild(marker);
        }

        // Open the annotation modal for a given page and coordinate.
        function openAnnotationModal(page, x, y) {
            const modal = document.getElementById('annotationModal');
            modal.style.display = "block";
            modal.dataset.page = page;
            modal.dataset.x = x;
            modal.dataset.y = y;
            document.getElementById('annotationPreview').innerHTML =
                `<strong>Selected text:</strong> "${currentSelection.text}"<br>` +
                `Page ${page} at (${Math.round(x)}, ${Math.round(y)})`;
        }

        // Cancel annotation modal.
        document.getElementById('cancelAnnotation').addEventListener('click', function () {
            document.getElementById('annotationModal').style.display = "none";
            document.getElementById('annotationText').value = "";
        });

        // Update the saveAnnotation click handler to include dimensions
        document.getElementById('saveAnnotation').addEventListener('click', function () {
            const comment = document.getElementById('annotationText').value.trim();
            if (!comment) {
                alert("Please enter a comment.");
                return;
            }
            const annotationType = document.getElementById('annotationType').value;
            const modal = document.getElementById('annotationModal');
            const page = parseInt(modal.dataset.page);
            const x = parseFloat(modal.dataset.x);
            const y = parseFloat(modal.dataset.y);
            const annotation = {
                id: uuidv4(),
                page,
                x,
                y,
                width: currentSelection.width,   // Include width
                height: currentSelection.height, // Include height
                comment,
                type: annotationType,
                selectedText: currentSelection.text
            };

            if (currentConversationId) {
                const conv = conversations.find(c => c.id === currentConversationId);
                if (conv) {
                    conv.annotations.push(annotation);
                    currentAnnotations = conv.annotations;
                    renderAnnotations(conv.annotations);
                    persistConversations();
                    renderPDF(currentPdfUrl, currentAnnotations);
                }
            }

            modal.style.display = "none";
            document.getElementById('annotationText').value = "";
        });

        // Render the annotation list in the right panel.
        function renderAnnotations(annotations) {
            const list = document.getElementById('annotationList');
            list.innerHTML = '';

            if (!annotations || annotations.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.style.cssText = `
                    text-align: center;
                    position: absolute;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    color: black;
                    width: 80%;
                `;
                emptyMessage.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100%;">
                        <i class="material-icons" style="font-size: 48px; opacity: 0.7; margin-bottom: 12px;">annotation</i>
                        <p style="margin: 0 0 8px 0; font-size: 14px; line-height: 1.5; text-align: center;">Select text to annotate</p>
                        <p style="margin: 0; font-size: 12px; line-height: 1.5; text-align: center; opacity: 0.8;">Once text is selected, mark as note or question to use AI to verify or answer your annotation</p>
                    </div>
                `;
                list.appendChild(emptyMessage);
                return;
            }

            annotations.forEach(ann => {
                const div = document.createElement('div');
                div.className = `annotation-item ${ann.type}`;

                // Define buttons based on annotation type
                let actionButtons = `
                    <button onclick="scrollToAnnotation('${ann.id}');">
                        <i class="material-icons">location_searching</i>
                        Go to
                    </button>
                `;

                // Add verify button and response viewer for notes
                if (ann.type === 'note') {
                    actionButtons += `
                        <button onclick="askAIVerify('${ann.id}');">
                            <i class="material-icons">verified</i>
                            ${ann.aiVerification ? 'Regenerate' : 'Verify'}
                        </button>
                        ${ann.aiVerification ? `
                            <button onclick="viewAIResponse('${ann.id}', 'verification')">
                                <i class="material-icons">visibility</i>
                                View Verification
                            </button>
                        ` : ''}
                    `;
                }

                // Add answer button and response viewer for questions
                if (ann.type === 'question') {
                    actionButtons += `
                        <button onclick="askAIAnswer('${ann.id}');">
                            <i class="material-icons">question_answer</i>
                            ${ann.aiAnswer ? 'Regenerate' : 'Answer'}
                        </button>
                        ${ann.aiAnswer ? `
                            <button onclick="viewAIResponse('${ann.id}', 'answer')">
                                <i class="material-icons">visibility</i>
                                View Answer
                            </button>
                        ` : ''}
                    `;
                }

                // Add delete button for all types
                actionButtons += `
                    <button onclick="deleteAnnotation('${ann.id}');">
                        <i class="material-icons">delete</i>
                        Delete
                    </button>
                `;

                div.innerHTML = `
                    <div class="metadata">Page ${ann.page} • ${ann.type}</div>
                    <div class="selected-text">"${ann.selectedText}"</div>
                    <div class="comment">${ann.comment}</div>
                    <div class="actions">
                        ${actionButtons}
                    </div>
                `;
                list.appendChild(div);
            });
        }

        // AI verification function
        async function askAIVerify(annotationId) {
            showLoading('AI is verifying the annotation...');
            try {
                const provider = getSelectedProvider();
                const conv = conversations.find(c => c.id === currentConversationId);
                if (!conv) {
                    console.error("No conversation found");
                    return;
                }
                const ann = conv.annotations.find(a => a.id === annotationId);
                if (!ann) {
                    console.error("No annotation found");
                    return;
                }

                // Get figures from the current page and surrounding pages
                const pageNum = ann.page;
                const relevantFigures = conv.extraction.pages
                    .filter(p => Math.abs(p.page_number - pageNum) <= 1)
                    .flatMap(p => p.figures.map(f => ({ ...f, page_number: p.page_number })));

                const requestData = {
                    provider: provider,  // Add provider to request
                    selectedText: ann.selectedText,
                    comment: ann.comment,
                    context: conv.extraction.pages[ann.page - 1].text,
                    figures: relevantFigures
                };

                console.log("Sending verification request with data:", requestData);

                const response = await fetch('/verify-annotation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                console.log("Got response:", response);
                const result = await response.json();
                console.log("Parsed result:", result);

                if (result.error) {
                    console.error("Error from server:", result.error);
                    alert('Error: ' + result.error);
                    return;
                }

                // Store the verification result
                conv.annotations.find(a => a.id === annotationId).aiVerification = result.explanation;
                persistConversations();
                renderAnnotations(conv.annotations);

                // Show the response
                viewAIResponse(annotationId, 'verification');
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to verify annotation');
            } finally {
                hideLoading();
            }
        }

        async function askAIAnswer(annotationId) {
            showLoading('AI is analyzing your question...');
            try {
                const provider = getSelectedProvider();
                const conv = conversations.find(c => c.id === currentConversationId);
                if (!conv) {
                    console.error("No conversation found");
                    return;
                }
                const ann = conv.annotations.find(a => a.id === annotationId);
                if (!ann) {
                    console.error("No annotation found");
                    return;
                }

                // Get figures from the current page and surrounding pages
                const pageNum = ann.page;
                const relevantFigures = conv.extraction.pages
                    .filter(p => Math.abs(p.page_number - pageNum) <= 1)
                    .flatMap(p => p.figures.map(f => ({ ...f, page_number: p.page_number })));

                const requestData = {
                    provider: provider,  // Add provider to request
                    selectedText: ann.selectedText,
                    question: ann.comment,
                    context: conv.extraction.pages[ann.page - 1].text,
                    figures: relevantFigures
                };

                console.log("Sending answer request with data:", requestData);

                const response = await fetch('/answer-question', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                console.log("Got response:", response);
                const result = await response.json();
                console.log("Parsed result:", result);

                if (result.error) {
                    console.error("Error from server:", result.error);
                    alert('Error: ' + result.error);
                    return;
                }

                // Store the answer
                conv.annotations.find(a => a.id === annotationId).aiAnswer = result.answer;
                persistConversations();
                renderAnnotations(conv.annotations);

                // Show the response
                viewAIResponse(annotationId, 'answer');
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to get AI answer');
            } finally {
                hideLoading();
            }
        }

        // Delete an annotation.
        function deleteAnnotation(annId) {
            const conv = conversations.find(c => c.id === currentConversationId);
            if (conv) {
                conv.annotations = conv.annotations.filter(a => a.id !== annId);
                currentAnnotations = conv.annotations;
                renderAnnotations(conv.annotations);
                renderPDF(currentPdfUrl, currentAnnotations);
                persistConversations();
            }
        }

        // Sidebar and conversation management.
        function renderSidebar() {
            const list = document.getElementById('conversationList');
            list.innerHTML = '';
            conversations.forEach(conv => {
                const item = document.createElement('div');
                item.className = 'conversation-item';
                item.dataset.id = conv.id;
                item.innerHTML = `<span>${conv.title}</span> <button onclick="deleteConversation('${conv.id}'); event.stopPropagation();">Delete</button>`;
                item.addEventListener('click', function () {
                    loadConversation(conv.id);
                });
                list.appendChild(item);
            });
        }

        function loadConversation(id) {
            const conv = conversations.find(c => c.id === id);
            if (conv) {
                currentConversationId = id;
                currentAnnotations = conv.annotations || [];
                renderPDF(conv.pdf_url, currentAnnotations);
                renderAnnotations(conv.annotations);
                document.getElementById('uploadPrompt').style.display = 'none';
                document.getElementById('welcomePanel').style.display = 'none';

                // Remove no-paper class from elements
                document.getElementById('sidebar').classList.remove('no-paper');
                document.getElementById('right-panel').classList.remove('no-paper');
                document.getElementById('chatButton').classList.remove('no-paper');
                document.getElementById('content').classList.remove('no-paper');
                document.getElementById('main').classList.remove('no-paper');
                document.getElementById('zoomControls').classList.remove('no-paper');
                document.getElementById('zoomControls').style.display = 'flex';

                document.getElementById('chatButton').classList.remove('disabled');
            }
        }

        function deleteConversation(id) {
            const conv = conversations.find(c => c.id === id);
            if (conv) {
                fetch(`/delete-upload/${id}`, {
                    method: 'POST'
                });

                conversations = conversations.filter(c => c.id !== id);
                if (currentConversationId === id) {
                    // Clear the PDF viewer more thoroughly
                    const pdfViewer = document.getElementById('pdfViewer');
                    pdfViewer.innerHTML = "";
                    pdfViewer.style.display = 'none';

                    // Close and clear chat interface
                    closeChatInterface();
                    currentChatHistory = [];
                    document.getElementById('chatMessages').innerHTML = "";

                    document.getElementById('annotationList').innerHTML = "";
                    currentConversationId = null;

                    // Show welcome panel and add no-paper class to elements
                    document.getElementById('welcomePanel').style.display = 'block';
                    document.getElementById('uploadPrompt').style.display = 'block';
                    document.getElementById('sidebar').classList.add('no-paper');
                    document.getElementById('right-panel').classList.add('no-paper');
                    document.getElementById('chatButton').classList.add('no-paper');
                    document.getElementById('content').classList.add('no-paper');
                    document.getElementById('main').classList.add('no-paper');
                    document.getElementById('zoomControls').classList.add('no-paper');
                    document.getElementById('zoomControls').style.display = 'none';

                    document.getElementById('chatButton').classList.add('disabled');
                }
                renderSidebar();
                persistConversations();
            }
        }

        // Add new helper function to close chat interface
        function closeChatInterface() {
            const chatInterface = document.getElementById('chatInterface');
            const chatButton = document.getElementById('chatButton');

            chatInterface.classList.remove('visible');
            setTimeout(() => {
                chatInterface.style.display = 'none';
            }, 300);
            chatButton.style.display = 'block';
        }

        document.getElementById('uploadForm').addEventListener('submit', async function (e) {
            e.preventDefault();
            showLoading('Uploading and processing PDF...');

            try {
                const formData = new FormData(this);
                const fileInput = document.querySelector('input[name="pdfFile"]');
                const fileName = fileInput.files[0].name;

                const response = await fetch('/upload', { method: 'POST', body: formData });
                if (!response.ok) {
                    throw new Error("Error uploading PDF");
                }
                const data = await response.json();
                const conv = {
                    id: data.upload_id,
                    title: fileName,
                    pdf_url: data.pdf_url,
                    extraction: data.extraction,
                    annotations: []
                };
                conversations.push(conv);
                renderSidebar();

                // Ensure PDF viewer is visible and empty before loading new PDF
                const pdfViewer = document.getElementById('pdfViewer');
                pdfViewer.innerHTML = "";
                pdfViewer.style.display = 'block';

                // Reset zoom to initial value for new uploads
                currentZoom = initialZoom;

                // Wait a brief moment for the DOM to update before rendering PDF
                await new Promise(resolve => setTimeout(resolve, 100));

                // Load the conversation and render the PDF
                await loadConversation(conv.id);

                persistConversations();

                // Reset file input and UI state
                this.reset();
                const fileLabel = document.querySelector('.custom-file-upload');
                const fileNameDisplay = document.querySelector('.file-name-display');
                const labelText = fileLabel.querySelector('.label-text');

                fileLabel.classList.remove('file-selected');
                fileNameDisplay.classList.remove('visible');
                fileNameDisplay.textContent = '';
                labelText.textContent = 'Choose File';

                document.getElementById('welcomePanel').style.display = 'none';

            } catch (error) {
                console.error("Upload error:", error);
                alert("Error uploading PDF: " + error.message);
            } finally {
                hideLoading();
            }
        });

        // Sidebar toggle functionality.
        document.getElementById('closeSidebar').addEventListener('click', function () {
            document.getElementById('sidebar').classList.add('closed');
            document.getElementById('openSidebar').style.display = 'block';
        });
        document.getElementById('openSidebar').addEventListener('click', function () {
            document.getElementById('sidebar').classList.remove('closed');
            document.getElementById('openSidebar').style.display = 'none';
        });

        // Simple UUID generator.
        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Load persistent conversations when the page loads.
        window.onload = function () {
            loadPersistentConversations();
            loadAIProviders();

            // Show welcome panel and hide elements if no paper is displayed
            if (conversations.length === 0 || !currentConversationId) {
                document.getElementById('uploadPrompt').style.display = 'block';
                document.getElementById('chatButton').classList.add('disabled');
                document.getElementById('welcomePanel').style.display = 'block';

                // Add no-paper class to elements
                document.getElementById('sidebar').classList.add('no-paper');
                document.getElementById('right-panel').classList.add('no-paper');
                document.getElementById('chatButton').classList.add('no-paper');
                document.getElementById('content').classList.add('no-paper');
                document.getElementById('main').classList.add('no-paper');
                document.getElementById('zoomControls').classList.add('no-paper');
                document.getElementById('zoomControls').style.display = 'none';
            }
        }

        // Update the handleTextSelection function to capture selection dimensions
        function handleTextSelection(event) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (!selectedText) {
                document.getElementById('selectionPopup').style.display = 'none';
                return;
            }

            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const popup = document.getElementById('selectionPopup');

            popup.style.display = 'block';
            popup.style.left = `${rect.left + window.scrollX}px`;
            popup.style.top = `${rect.bottom + window.scrollY}px`;

            const pageDiv = event.target.closest('.pdf-page');
            const pageRect = pageDiv.getBoundingClientRect();

            currentSelection = {
                text: selectedText,
                page: parseInt(pageDiv.dataset.pageNumber),
                x: rect.left - pageRect.left,
                y: rect.top - pageRect.top,
                width: rect.width,   // Add width of selection
                height: rect.height  // Add height of selection
            };
        }

        // Add selection popup button handler
        document.getElementById('addAnnotationBtn').addEventListener('click', function () {
            if (currentSelection) {
                openAnnotationModal(
                    currentSelection.page,
                    currentSelection.x,
                    currentSelection.y
                );
                document.getElementById('selectionPopup').style.display = 'none';
            }
        });

        // Close selection popup when clicking outside
        document.addEventListener('mousedown', function (event) {
            if (!event.target.closest('#selectionPopup')) {
                document.getElementById('selectionPopup').style.display = 'none';
            }
        });

        function showLoading(message = 'Processing...') {
            // For chat-specific loading, use the loading overlay inside chat interface
            if (message === 'AI is thinking...') {
                const chatOverlay = document.querySelector('#chatInterface .loading-overlay');
                const text = chatOverlay.querySelector('.loading-text');
                text.textContent = message;
                chatOverlay.style.display = 'flex';
            } else {
                // For other loading scenarios, use the main loading overlay
                const overlay = document.querySelector('body > .loading-overlay');
                const text = overlay.querySelector('.loading-text');
                text.textContent = message;
                overlay.style.display = 'flex';
            }
        }

        function hideLoading() {
            // Hide both loading overlays
            document.querySelectorAll('.loading-overlay').forEach(overlay => {
                overlay.style.display = 'none';
            });
        }

        // Chat functionality
        const chatButton = document.getElementById('chatButton');
        const chatInterface = document.getElementById('chatInterface');
        const closeChatButton = document.getElementById('closeChatButton');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');

        chatButton.addEventListener('click', () => {
            chatInterface.style.display = 'flex';
            // Small delay to trigger animation
            setTimeout(() => {
                chatInterface.classList.add('visible');
            }, 10);
            chatButton.style.display = 'none';
        });

        closeChatButton.addEventListener('click', () => {
            chatInterface.classList.remove('visible');
            // Wait for animation to complete before hiding
            setTimeout(() => {
                chatInterface.style.display = 'none';
            }, 300);
            chatButton.style.display = 'block';
        });

        async function sendChatMessage(message) {
            if (!currentConversationId) {
                alert('Please upload a paper first');
                return;
            }

            addMessageToChat('user', message);
            showLoading('AI is thinking...');

            try {
                const provider = getSelectedProvider();
                const requestData = {
                    message: message,
                    provider: provider,
                    paper_context: conversations.find(c => c.id === currentConversationId).extraction
                };

                const response = await fetch('/chat-with-paper', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                const result = await response.json();
                if (result.error) {
                    throw new Error(result.error);
                }

                addMessageToChat('ai', result.response);
            } catch (error) {
                console.error('Error:', error);
                addMessageToChat('system', 'Error: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        function addMessageToChat(role, content, save = true) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}-message`;

            // Use marked to parse markdown for AI messages
            if (role === 'ai') {
                messageDiv.innerHTML = marked.parse(content);
            } else {
                messageDiv.textContent = content;
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            if (save) {
                currentChatHistory.push({ role, content });
                saveChatHistory();
            }
        }

        sendChatButton.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                sendChatMessage(message);
                chatInput.value = '';
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatButton.click();
            }
        });

        // Add new function to load chat history
        async function loadChatHistory(conversationId) {
            try {
                const response = await fetch(`/chat-history/${conversationId}`);
                currentChatHistory = await response.json();
                renderChatHistory();
            } catch (error) {
                console.error('Error loading chat history:', error);
                currentChatHistory = [];
            }
        }

        // Add function to render chat history
        function renderChatHistory() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            currentChatHistory.forEach(msg => {
                addMessageToChat(msg.role, msg.content, false);
            });
        }

        // Add function to save chat history
        async function saveChatHistory() {
            if (!currentConversationId) return;

            try {
                await fetch(`/chat-history/${currentConversationId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(currentChatHistory)
                });
            } catch (error) {
                console.error('Error saving chat history:', error);
            }
        }

        // Add file selection handler
        document.querySelector('input[type="file"]').addEventListener('change', function (e) {
            const fileName = e.target.files[0]?.name;
            const fileLabel = e.target.closest('.custom-file-upload');
            const fileNameDisplay = document.querySelector('.file-name-display');

            if (fileName) {
                fileLabel.classList.add('file-selected');
                fileNameDisplay.textContent = fileName;
                fileNameDisplay.classList.add('visible');
                fileLabel.querySelector('.label-text').textContent = 'File Selected';
            } else {
                fileLabel.classList.remove('file-selected');
                fileNameDisplay.classList.remove('visible');
                fileLabel.querySelector('.label-text').textContent = 'Choose File';
            }
        });

        // Update the scrollToAnnotation function to account for zoom
        function scrollToAnnotation(annotationId) {
            const conv = conversations.find(c => c.id === currentConversationId);
            if (!conv) return;

            const annotation = conv.annotations.find(a => a.id === annotationId);
            if (!annotation) return;

            const pageDiv = document.querySelector(`.pdf-page[data-page-number="${annotation.page}"]`);
            if (!pageDiv) return;

            // Calculate the scaled position
            const scaledY = (annotation.y * currentZoom) + pageDiv.offsetTop;

            // Scroll the page into view with the scaled position
            document.getElementById('left-panel').scrollTo({
                top: scaledY - window.innerHeight / 2,
                behavior: 'smooth'
            });

            // Flash the annotation marker with type-specific color
            const marker = pageDiv.querySelector(`.annotation-marker[data-annotation-id="${annotationId}"]`);
            if (marker) {
                marker.style.transition = 'all 0.3s ease';
                marker.style.transform = 'scale(1.5)';

                // Set highlight color based on annotation type
                if (annotation.type === 'note') {
                    marker.style.background = 'rgba(26, 54, 93, 0.8)'; // #1a365d
                } else if (annotation.type === 'question') {
                    marker.style.background = 'rgba(128, 0, 32, 0.8)'; // #800020
                }

                setTimeout(() => {
                    marker.style.transform = 'scale(1)';
                    // Reset to original transparency
                    if (annotation.type === 'note') {
                        marker.style.background = 'rgba(26, 54, 93, 0.3)';
                    } else if (annotation.type === 'question') {
                        marker.style.background = 'rgba(128, 0, 32, 0.3)';
                    }
                }, 1000);
            }
        }

        // Add this after window.onload
        async function loadAIProviders() {
            try {
                const response = await fetch('/ai-providers');
                const data = await response.json();
                const select = document.getElementById('aiProvider');
                select.innerHTML = ''; // Clear existing options

                // Add available providers from the backend
                data.providers.forEach(provider => {
                    const option = document.createElement('option');
                    option.value = provider.id;
                    option.textContent = provider.name;
                    option.disabled = !provider.enabled;
                    select.appendChild(option);
                });

                // If no providers are available, add a default disabled option
                if (data.providers.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = 'No AI providers available';
                    option.disabled = true;
                    select.appendChild(option);
                }
            } catch (error) {
                console.error('Error loading AI providers:', error);
            }
        }

        // Update the existing functions to include the selected provider
        function getSelectedProvider() {
            return document.getElementById('aiProvider').value;
        }

        // Add new function to view AI responses
        function viewAIResponse(annotationId, type) {
            const conv = conversations.find(c => c.id === currentConversationId);
            const ann = conv.annotations.find(a => a.id === annotationId);

            if (!ann) return;

            const response = type === 'verification' ? ann.aiVerification : ann.aiAnswer;
            if (!response) return;

            // Create modal HTML with enhanced styling and section organization
            const modalHtml = `
                <div class="ai-response-modal">
                    <h3>
                        <i class="material-icons">${type === 'verification' ? 'verified' : 'question_answer'}</i>
                        AI ${type === 'verification' ? 'Verification' : 'Answer'}
                    </h3>
                    <div class="content">
                        ${formatAIResponse(response)}
                    </div>
                    <div class="actions">
                        <button onclick="this.closest('.ai-response-modal').remove()">
                            <i class="material-icons">close</i>
                            Close
                        </button>
                        <button onclick="if(confirm('Regenerate response?')) { ${type === 'verification' ? 'askAIVerify' : 'askAIAnswer'}('${annotationId}'); this.closest('.ai-response-modal').remove(); }">
                            <i class="material-icons">refresh</i>
                            Regenerate
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function formatAIResponse(response) {
            // Parse the markdown content
            let html = marked.parse(response);

            // Add section styling and icons
            html = html.replace(/<h2>Answer:/g, '<div class="response-section"><h3><i class="material-icons section-icon">lightbulb</i>Answer:</h3>');
            html = html.replace(/<h2>Paper Evidence:/g, '<div class="response-section"><h3><i class="material-icons section-icon">description</i>Paper Evidence:</h3>');
            html = html.replace(/<h2>Web Sources:/g, '<div class="response-section"><h3><i class="material-icons section-icon">public</i>Web Sources:</h3>');
            html = html.replace(/<h2>General Knowledge:/g, '<div class="response-section"><h3><i class="material-icons section-icon">psychology</i>General Knowledge:</h3>');

            // Add closing div for sections
            html = html.replace(/<h2>/g, '</div><h2>');

            // Style web citations
            html = html.replace(
                /\[(.*?)\]\((https?:\/\/[^\s\)]+)\)/g,
                '<div class="web-citation">📚 <a href="$2" target="_blank">$1</a></div>'
            );

            // Style paper quotes
            html = html.replace(
                /(".*?")\s*from the paper/g,
                '<div class="paper-citation">$1</div>'
            );

            return html;
        }

        // Update loading state display
        function showAILoading() {
            return `
                <div class="ai-response-loading">
                    <div class="spinner"></div>
                    <p>Processing request...</p>
                </div>
            `;
        }

        // Add clear chat functionality
        document.getElementById('clearChatButton').addEventListener('click', async () => {
            if (confirm('Are you sure you want to clear the chat history?')) {
                currentChatHistory = [];
                document.getElementById('chatMessages').innerHTML = '';

                // Save empty chat history to server
                if (currentConversationId) {
                    try {
                        await fetch(`/chat-history/${currentConversationId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify([])
                        });
                    } catch (error) {
                        console.error('Error clearing chat history:', error);
                    }
                }
            }
        });

        // Add this function
        function selectAnnotationType(type) {
            // Update buttons
            document.querySelectorAll('.type-selector').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.type === type) {
                    btn.classList.add('selected');
                }
            });

            // Update hidden select value
            document.getElementById('annotationType').value = type;
        }

        // Add this to initialize the UI when modal opens
        document.getElementById('addAnnotationBtn').addEventListener('click', function () {
            if (currentSelection) {
                openAnnotationModal(
                    currentSelection.page,
                    currentSelection.x,
                    currentSelection.y
                );
                // Select default type (note)
                selectAnnotationType('note');
                document.getElementById('selectionPopup').style.display = 'none';
            }
        });

        // Add these new functions
        function adjustZoom(delta) {
            const newZoom = currentZoom + delta;
            if (newZoom >= 0.5 && newZoom <= 3) { // Limit zoom range
                currentZoom = newZoom;
                renderPDF(currentPdfUrl, currentAnnotations);
            }
        }

        function updateZoomDisplay() {
            const percentage = Math.round(currentZoom * 100);
            document.getElementById('zoomLevel').textContent = `${percentage}%`;
        }
    </script>
</body>

</html>