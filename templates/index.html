<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Synopsis AI</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Source+Sans+3:wght@300;400;500;600&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Design System - CSS Custom Properties */
        :root {
            /* Colors - Academic Palette */
            --color-background: #FAFAF8;
            --color-surface: #F5F4F0;
            --color-surface-elevated: #FFFFFF;
            --color-primary-text: #1C1C1E;
            --color-secondary-text: #6B6B6F;
            --color-tertiary-text: #8E8E93;
            --color-accent-primary: #2D6A4F;
            --color-accent-secondary: #1B4332;
            --color-border: #E8E6E1;
            --color-border-light: #F0EEE9;
            --color-hover: rgba(45, 106, 79, 0.08);
            --color-active: rgba(45, 106, 79, 0.12);

            /* Typography */
            --font-display: 'Playfair Display', Georgia, serif;
            --font-body: 'Source Sans 3', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-2xl: 48px;

            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-full: 9999px;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(28, 28, 30, 0.04);
            --shadow-md: 0 4px 12px rgba(28, 28, 30, 0.08);
            --shadow-lg: 0 8px 24px rgba(28, 28, 30, 0.12);

            /* Transitions */
            --transition-fast: 150ms ease;
            --transition-normal: 250ms ease;
            --transition-slow: 350ms ease;
        }

        /* Overall layout */
        body {
            margin: 0;
            font-family: var(--font-body);
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: var(--color-background);
            color: var(--color-primary-text);
            font-weight: 400;
            font-size: 15px;
            line-height: 1.6;
            position: relative;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: var(--font-display);
            font-weight: 500;
            color: var(--color-primary-text);
            letter-spacing: -0.01em;
            line-height: 1.3;
        }

        button {
            font-family: var(--font-body);
            font-weight: 500;
        }

        input,
        textarea,
        select {
            font-family: var(--font-body);
            font-weight: 400;
        }

        #chatButton {
            position: fixed;
            bottom: 24px;
            right: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: var(--color-accent-primary);
            color: #ffffff;
            border-radius: var(--radius-full);
            padding: 0 28px;
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.01em;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            white-space: nowrap;
            height: 48px;
            line-height: 48px;
            opacity: 1;
            transition: all var(--transition-normal);
            border: none;
        }

        #chatButton:hover {
            background-color: #1B4332;
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        #chatButton.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        #chatButton .material-icons {
            font-size: 20px;
            line-height: 1;
        }

        /* Sidebar styling */
        #sidebar {
            width: 260px;
            min-width: 260px;
            background-color: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: var(--space-lg);
            box-sizing: border-box;
            overflow-y: auto;
            transition: transform var(--transition-slow);
        }

        #sidebar.closed {
            transform: translateX(-100%);
        }

        #sidebar .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--color-border);
        }

        #sidebar .sidebar-header h3 {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 500;
            margin: 0;
            color: var(--color-primary-text);
        }

        #closeSidebar {
            background: transparent;
            color: var(--color-secondary-text);
            border: none;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
        }

        #closeSidebar:hover {
            background: var(--color-hover);
            color: var(--color-primary-text);
        }

        #closeSidebar .material-icons {
            font-size: 20px;
        }

        #openSidebar {
            position: absolute;
            top: var(--space-md);
            left: var(--space-md);
            z-index: 1100;
            background: var(--color-surface-elevated);
            color: var(--color-secondary-text);
            border: 1px solid var(--color-border);
            padding: 0;
            width: 40px;
            height: 40px;
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-sm);
        }

        #openSidebar:hover {
            background: var(--color-surface);
            color: var(--color-primary-text);
        }

        #openSidebar .material-icons {
            font-size: 20px;
        }

        #sidebar .conversation-item {
            padding: var(--space-md);
            border-bottom: none;
            cursor: pointer;
            display: block;
            background-color: transparent;
            margin-bottom: var(--space-sm);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            box-shadow: none;
            border-left: 3px solid transparent;
        }

        #sidebar .conversation-item:hover {
            background-color: var(--color-hover);
            border-left-color: var(--color-accent-primary);
        }

        #sidebar .conversation-item span {
            display: block;
            margin-bottom: var(--space-xs);
            font-size: 14px;
            color: var(--color-primary-text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #sidebar .conversation-item button {
            float: right;
            font-size: 12px;
            padding: 4px 8px;
            background: transparent;
            color: var(--color-secondary-text);
            border: 1px solid var(--color-border);
        }

        #sidebar .conversation-item button:hover {
            background: var(--color-accent-primary);
            color: white;
            border-color: var(--color-accent-primary);
        }

        /* Main content area */
        #content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: calc(100% - 260px);
            margin-left: 0;
            transition: all var(--transition-slow);
            position: relative;
            background-color: var(--color-background);
        }

        #sidebar.closed+#openSidebar+#content {
            width: 100%;
            margin-left: -260px;
        }

        #topbar {
            background-color: var(--color-surface-elevated);
            padding: var(--space-md) var(--space-xl);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            color: var(--color-primary-text);
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }

        #topbar .left-section {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            z-index: 0;
            pointer-events: none;
        }

        #topbar h1 {
            flex-grow: 1;
            margin: 0;
            font-size: 1.2em;
            text-align: center;
            padding: 10px 0;
        }

        #topbar .brand-name {
            pointer-events: auto;
        }

        /* Upload form in topbar */
        #uploadForm {
            margin-left: auto;
            z-index: 1;
            display: flex;
            gap: var(--space-sm);
            align-items: center;
            min-width: fit-content;
            margin-right: var(--space-sm);
        }

        #main {
            flex-grow: 1;
            display: flex;
            overflow: hidden;
        }

        /* Left panel: PDF viewer using PDF.js */
        #left-panel {
            flex-grow: 1;
            padding: var(--space-lg);
            box-sizing: border-box;
            overflow: auto;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #pdfViewer {
            position: relative;
            transform-origin: top center;
            transition: transform var(--transition-fast);
        }

        /* Zoom controls - hidden by default, shown via JS when paper loads */
        #zoomControls {
            display: none;
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            gap: var(--space-sm);
            background: var(--color-surface-elevated);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-md);
            border: 1px solid var(--color-border);
            z-index: 100;
        }

        #zoomControls.no-paper {
            display: none !important;
        }

        #zoomControls button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            padding: 0;
            background: transparent;
            color: var(--color-primary-text);
            border: none;
            border-radius: var(--radius-sm);
        }

        #zoomControls button:hover {
            background: var(--color-hover);
        }

        #zoomControls span {
            display: flex;
            align-items: center;
            padding: 0 var(--space-sm);
            color: var(--color-secondary-text);
            font-weight: 500;
            font-size: 13px;
            min-width: 50px;
            justify-content: center;
        }

        .pdf-page {
            position: relative;
            margin-bottom: var(--space-lg);
            box-shadow: var(--shadow-md);
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        /* Update annotation marker style */
        .annotation-marker {
            position: absolute;
            border: none;
            cursor: pointer;
            border-radius: 3px;
            transition: all var(--transition-fast);
            padding: 2px 4px;
        }

        .annotation-marker.note {
            background: rgba(44, 62, 80, 0.25);
        }

        .annotation-marker.note:hover {
            background: rgba(44, 62, 80, 0.4);
        }

        .annotation-marker.question {
            background: rgba(45, 106, 79, 0.25);
        }

        .annotation-marker.question:hover {
            background: rgba(45, 106, 79, 0.4);
        }

        /* Right panel: Extraction data & annotations list */
        #right-panel {
            width: 320px;
            padding: var(--space-lg);
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            overflow-y: auto;
            position: relative;
        }

        #right-panel h3 {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 500;
            margin: 0 0 var(--space-md) 0;
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--color-border);
            color: var(--color-primary-text);
        }

        #annotationList {
            border-top: none;
            padding-top: 0;
        }

        .annotation-item {
            padding: var(--space-md);
            margin-bottom: var(--space-md);
            border-radius: var(--radius-md);
            background-color: var(--color-surface-elevated);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--color-border);
            font-size: 13px;
            line-height: 1.6;
            position: relative;
        }

        .annotation-item::before {
            display: none;
        }

        .annotation-item .selected-text {
            color: var(--color-secondary-text);
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--color-border-light);
            font-style: italic;
            font-size: 12px;
        }

        .annotation-item .comment {
            color: var(--color-primary-text);
            margin-bottom: var(--space-md);
        }

        .annotation-item .metadata {
            color: var(--color-tertiary-text);
            font-size: 11px;
            margin-bottom: var(--space-sm);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .annotation-item .actions {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
            margin-top: var(--space-md);
            padding-top: var(--space-sm);
            border-top: 1px solid var(--color-border-light);
        }

        .annotation-item button {
            flex: 1;
            min-width: calc(50% - 2px);
            font-size: 11px;
            padding: var(--space-sm) var(--space-sm);
            border-radius: var(--radius-sm);
            background-color: var(--color-surface);
            color: var(--color-primary-text);
            border: 1px solid var(--color-border);
            box-shadow: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            transition: all var(--transition-fast);
        }

        .annotation-item button:hover {
            background-color: var(--color-accent-primary);
            color: white;
            border-color: var(--color-accent-primary);
        }

        .annotation-item button .material-icons {
            font-size: 14px;
            margin-right: 4px;
        }

        /* Annotation Modal styling */
        #annotationModal {
            display: none;
            position: fixed;
            z-index: 1100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(28, 28, 30, 0.4);
            backdrop-filter: blur(8px);
        }

        #annotationModalContent {
            background-color: var(--color-surface-elevated);
            margin: 12% auto;
            padding: var(--space-xl);
            border: 1px solid var(--color-border);
            width: 440px;
            max-width: 90%;
            position: relative;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
        }

        #annotationModalContent h3 {
            font-family: var(--font-display);
            font-size: 20px;
            margin: 0 0 var(--space-md) 0;
            text-align: center;
        }

        #annotationModalContent textarea {
            width: 100%;
            height: 100px;
            border-radius: var(--radius-md);
            border: 1px solid var(--color-border);
            padding: var(--space-md);
            transition: border var(--transition-fast);
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
        }

        #annotationModalContent textarea:focus {
            outline: none;
            border-color: var(--color-accent-primary);
        }

        #annotationModalContent button {
            margin-top: var(--space-sm);
        }

        #saveAnnotation {
            background-color: var(--color-accent-primary);
            color: white;
            border-radius: var(--radius-full);
            padding: var(--space-sm) var(--space-xl);
        }

        #saveAnnotation:hover {
            background-color: #1B4332;
        }

        #cancelAnnotation {
            background: transparent;
            color: var(--color-secondary-text);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-full);
            padding: var(--space-sm) var(--space-xl);
        }

        #cancelAnnotation:hover {
            background: var(--color-hover);
            color: var(--color-primary-text);
        }

        /* Selection popup menu */
        #selectionPopup {
            display: none;
            position: absolute;
            background: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            padding: var(--space-xs);
            z-index: 1000;
        }

        #addAnnotationBtn {
            background: var(--color-accent-primary);
            color: white;
            border-radius: var(--radius-sm);
            font-size: 13px;
            padding: var(--space-sm) var(--space-md);
        }

        #addAnnotationBtn:hover {
            background: #1B4332;
        }

        /* Add styles for PDF.js text layer */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
        }

        .textLayer>span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: var(--color-accent-primary);
            border-radius: 3px;
        }

        .textLayer .highlight.selected {
            background-color: var(--color-accent-secondary);
        }

        /* Loading overlay */
        .loading-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(250, 250, 248, 0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            backdrop-filter: blur(8px);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--color-border);
            border-radius: 50%;
            border-top-color: var(--color-accent-primary);
            animation: spin 0.8s ease-in-out infinite;
        }

        .loading-text {
            color: var(--color-primary-text);
            margin-top: var(--space-md);
            font-size: 14px;
            font-weight: 500;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Base button styles */
        button {
            background-color: var(--color-accent-secondary);
            color: #ffffff;
            border: none;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-size: 13px;
            font-weight: 500;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* Primary button variant */
        button.primary {
            background-color: var(--color-accent-primary);
            border-radius: var(--radius-full);
        }

        button.primary:hover {
            background-color: #1B4332;
        }

        /* Secondary/outline button variant */
        button.secondary {
            background-color: transparent;
            color: var(--color-primary-text);
            border: 1px solid var(--color-border);
        }

        button.secondary:hover {
            background-color: var(--color-hover);
            border-color: var(--color-accent-primary);
        }

        /* Upload prompt */
        #uploadPrompt {
            display: none;
            text-align: center;
            padding: var(--space-lg);
        }

        .custom-file-upload {
            display: inline-flex;
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            background-color: var(--color-surface);
            color: var(--color-primary-text);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-full);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-size: 13px;
            font-weight: 500;
            height: 40px;
            box-sizing: border-box;
            white-space: nowrap;
            min-width: fit-content;
        }

        .custom-file-upload:hover {
            background-color: var(--color-hover);
            border-color: var(--color-accent-primary);
        }

        .custom-file-upload .material-icons {
            margin-right: var(--space-sm);
            font-size: 18px;
            color: var(--color-secondary-text);
        }

        input[type="file"] {
            display: none;
        }

        #uploadForm button {
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: 13px;
            height: 40px;
            padding: var(--space-sm) var(--space-lg);
            box-sizing: border-box;
            background-color: var(--color-accent-primary);
            border-radius: var(--radius-full);
        }

        #uploadForm button:hover {
            background-color: #1B4332;
        }

        #uploadForm button .material-icons {
            font-size: 18px;
        }

        .custom-file-upload.file-selected {
            background-color: var(--color-accent-primary);
            color: #ffffff;
            border-color: var(--color-accent-primary);
        }

        .custom-file-upload.file-selected .material-icons {
            color: #ffffff;
        }

        .file-name-display {
            font-size: 12px;
            color: var(--color-secondary-text);
            margin-left: var(--space-sm);
            opacity: 0;
            transition: opacity var(--transition-normal);
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 1;
        }

        .file-name-display.visible {
            opacity: 1;
        }

        /* Disclaimer */
        .disclaimer {
            position: fixed;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: var(--color-tertiary-text);
            text-align: center;
            font-family: var(--font-body);
            z-index: 50;
            pointer-events: none;
            pointer-events: none;
        }

        /* Update annotation item style for different types */
        .annotation-item.note::before {
            display: none;
        }

        .annotation-item.question::before {
            display: none;
        }

        .annotation-item.note {
            border-left: 3px solid var(--color-accent-secondary);
        }

        .annotation-item.question {
            border-left: 3px solid var(--color-accent-primary);
        }

        .ai-response-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--color-surface-elevated);
            padding: var(--space-xl);
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            border-radius: var(--radius-lg);
            display: flex;
            flex-direction: column;
            border: 1px solid var(--color-border);
        }

        .ai-response-modal .content {
            overflow-y: auto;
            padding: var(--space-lg);
            margin: var(--space-md) 0;
            background: var(--color-surface);
            border-radius: var(--radius-md);
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-primary-text);
        }

        /* Response Section Styling */
        .response-section {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--color-border);
        }

        .response-section:last-child {
            border-bottom: none;
        }

        .response-section h3 {
            font-family: var(--font-display);
            color: var(--color-primary-text);
            font-size: 16px;
            font-weight: 500;
            margin-bottom: var(--space-md);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        /* Citation Styling */
        .web-citation {
            background: var(--color-surface);
            border-left: 3px solid var(--color-accent-secondary);
            padding: var(--space-md);
            margin: var(--space-sm) 0;
            border-radius: var(--radius-sm);
            font-size: 13px;
        }

        .web-citation a {
            color: var(--color-accent-secondary);
            text-decoration: none;
            font-weight: 500;
        }

        .web-citation a:hover {
            text-decoration: underline;
        }

        /* Paper Citation Styling */
        .paper-citation {
            background: rgba(45, 106, 79, 0.06);
            border-left: 3px solid var(--color-accent-primary);
            padding: var(--space-md);
            margin: var(--space-sm) 0;
            border-radius: var(--radius-sm);
            font-size: 13px;
        }

        /* Section Icons */
        .section-icon {
            font-size: 18px !important;
            color: var(--color-secondary-text);
        }

        /* Loading State */
        .ai-response-loading {
            text-align: center;
            padding: var(--space-xl);
        }

        .ai-response-loading .spinner {
            border: 3px solid var(--color-border);
            border-top-color: var(--color-accent-primary);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 0.8s ease-in-out infinite;
            margin: 0 auto var(--space-md);
        }

        /* Chat Interface Styling - hidden by default, shown via .visible class */
        #chatInterface {
            display: none;
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 420px;
            height: 620px;
            background: var(--color-surface-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            z-index: 1001;
            box-shadow: var(--shadow-lg);
            flex-direction: column;
            transition: all var(--transition-slow);
            transform-origin: bottom right;
            transform: scale(0);
            opacity: 0;
            overflow: hidden;
            resize: both;
            min-width: 400px;
            min-height: 600px;
        }

        #chatInterface.visible {
            display: flex;
            transform: scale(1);
            opacity: 1;
        }

        #chatInterface.expanded {
            position: fixed;
            top: 24px !important;
            right: 24px !important;
            bottom: 24px !important;
            width: calc(100% - 48px) !important;
            height: calc(100% - 48px) !important;
            max-width: none !important;
            max-height: none !important;
            resize: none;
        }

        #chatInterface .chat-header {
            padding: var(--space-md) var(--space-lg);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--color-surface-elevated);
            border-top-left-radius: var(--radius-lg);
            border-top-right-radius: var(--radius-lg);
            gap: var(--space-md);
        }

        #chatInterface .chat-header h3 {
            margin: 0;
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 500;
            color: var(--color-primary-text);
        }

        #chatInterface .chat-header .header-buttons {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        #chatInterface #closeChatButton {
            background: transparent;
            color: var(--color-secondary-text);
            border: none;
            font-size: 24px;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
        }

        #chatInterface #closeChatButton:hover {
            background: var(--color-hover);
            color: var(--color-primary-text);
        }

        #chatMessages {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            padding: var(--space-lg);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            background: var(--color-background);
        }

        #chatMessages::-webkit-scrollbar {
            width: 6px;
        }

        #chatMessages::-webkit-scrollbar-track {
            background: transparent;
        }

        #chatMessages::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 3px;
        }

        #chatMessages::-webkit-scrollbar-thumb:hover {
            background-color: var(--color-secondary-text);
        }

        .chat-message {
            max-width: 85%;
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-lg);
            line-height: 1.6;
            font-size: 14px;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .chat-message.user-message {
            background-color: var(--color-primary-text);
            color: #ffffff;
            align-self: flex-end;
            border-bottom-right-radius: var(--radius-sm);
        }

        .chat-message.ai-message {
            background-color: var(--color-surface);
            color: var(--color-primary-text);
            border: 1px solid var(--color-border);
            align-self: flex-start;
            border-bottom-left-radius: var(--radius-sm);
        }

        .chat-message.system-message {
            background-color: var(--color-surface);
            color: var(--color-secondary-text);
            align-self: center;
            font-size: 12px;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-full);
        }

        .chat-input-container {
            flex: 0 0 auto;
            padding: var(--space-md) var(--space-lg);
            border-top: 1px solid var(--color-border);
            background: var(--color-surface-elevated);
            border-bottom-left-radius: var(--radius-lg);
            border-bottom-right-radius: var(--radius-lg);
        }

        #chatInput {
            width: 100%;
            min-height: 52px;
            max-height: 150px;
            padding: var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            resize: none;
            font-size: 14px;
            font-family: var(--font-body);
            line-height: 1.5;
            margin-bottom: var(--space-sm);
            box-shadow: none;
            transition: border-color var(--transition-fast);
            box-sizing: border-box;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--color-border) transparent;
            background: var(--color-background);
        }

        #chatInput:focus {
            outline: none;
            border-color: var(--color-accent-primary);
        }

        #chatInput::-webkit-scrollbar {
            width: 6px;
        }

        #chatInput::-webkit-scrollbar-track {
            background: transparent;
        }

        #chatInput::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 3px;
        }

        #sendChatButton {
            width: 100%;
            padding: var(--space-md);
            background-color: var(--color-accent-primary);
            color: #ffffff;
            font-weight: 600;
            border-radius: var(--radius-md);
            font-size: 14px;
        }

        #sendChatButton:hover {
            background-color: #1B4332;
        }

        #sendChatButton:disabled {
            background-color: var(--color-border);
            color: var(--color-tertiary-text);
            cursor: not-allowed;
        }

        /* Clear chat button */
        #clearChatButton {
            background: transparent;
            color: var(--color-secondary-text);
            border: none;
            font-size: 12px;
            padding: var(--space-xs) var(--space-sm);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            border-radius: var(--radius-sm);
        }

        #clearChatButton:hover {
            background: var(--color-hover);
            color: var(--color-primary-text);
        }

        #clearChatButton .material-icons {
            font-size: 16px;
        }

        /* Code blocks within messages */
        .chat-message pre {
            max-width: 100%;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            scrollbar-width: thin;
            scrollbar-color: var(--color-border) transparent;
            background: var(--color-background);
            padding: var(--space-md);
            border-radius: var(--radius-sm);
            font-size: 13px;
            margin: var(--space-sm) 0;
        }

        .chat-message pre::-webkit-scrollbar {
            height: 6px;
        }

        .chat-message pre::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-message pre::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 3px;
        }

        .chat-message code {
            word-break: break-word;
            white-space: pre-wrap;
            font-size: 13px;
        }

        /* Welcome Panel Styles */
        #welcomePanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--color-surface-elevated);
            padding: var(--space-2xl);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--color-border);
            max-width: 560px;
            width: 90%;
            z-index: 1000;
        }

        #welcomePanel h2 {
            font-family: var(--font-display);
            color: var(--color-primary-text);
            margin-top: 0;
            margin-bottom: var(--space-xl);
            text-align: center;
            font-size: 24px;
            font-weight: 500;
        }

        .step-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        .step {
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
            padding: var(--space-lg);
            background: var(--color-surface);
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
            border: 1px solid transparent;
        }

        .step:hover {
            border-color: var(--color-accent-primary);
            transform: translateX(4px);
        }

        .step .step-number {
            background: var(--color-accent-primary);
            color: #ffffff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        .step .step-content {
            flex: 1;
        }

        .step h3 {
            font-family: var(--font-display);
            margin: 0 0 var(--space-xs) 0;
            color: var(--color-primary-text);
            font-size: 16px;
            font-weight: 500;
        }

        .step p {
            margin: 0;
            color: var(--color-secondary-text);
            line-height: 1.6;
            font-size: 14px;
        }

        /* No paper state */
        #sidebar.no-paper,
        #right-panel.no-paper,
        #chatButton.no-paper {
            display: none !important;
        }

        #content.no-paper {
            margin-left: 0 !important;
            width: 100% !important;
        }

        #main.no-paper {
            justify-content: center;
            align-items: center;
        }

        /* Type selector for annotations */
        .type-selector {
            padding: var(--space-sm) var(--space-lg);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            color: var(--color-primary-text);
            transition: all var(--transition-fast);
            border-radius: var(--radius-full);
        }

        .type-selector:hover {
            border-color: var(--color-accent-primary);
            background: var(--color-hover);
        }

        .type-selector.selected {
            background: var(--color-accent-primary);
            color: white;
            border-color: var(--color-accent-primary);
        }

        .type-selector .material-icons {
            font-size: 18px;
        }

        /* Chat-specific loading styles */
        #chatInterface .loading-overlay {
            border-radius: var(--radius-lg);
        }

        #chatInterface .loading-text {
            font-size: 13px;
        }

        /* Branding styles */
        .brand-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-md);
        }

        .brand-name {
            font-family: var(--font-display);
            font-size: 28px;
            font-weight: 500;
            color: var(--color-primary-text);
            letter-spacing: -0.5px;
        }

        /* Progress bar */
        #progressBarContainer {
            position: fixed;
            bottom: 24px;
            left: 24px;
            width: 240px;
            background: var(--color-surface-elevated);
            border-radius: var(--radius-md);
            border: 1px solid var(--color-border);
            z-index: 1000;
            padding: var(--space-md);
            box-shadow: var(--shadow-md);
        }

        #progressBar {
            width: 0%;
            height: 6px;
            background: var(--color-accent-primary);
            border-radius: var(--radius-full);
            transition: width var(--transition-normal);
        }

        #progressLabel {
            display: block;
            text-align: center;
            font-size: 12px;
            color: var(--color-secondary-text);
            margin-top: var(--space-sm);
        }

        /* Math annotation styles */
        .math-annotation {
            background-color: rgba(45, 106, 79, 0.08);
            border-left: 3px solid var(--color-accent-primary);
            padding: var(--space-md);
            margin: var(--space-sm) 0;
            border-radius: var(--radius-sm);
        }

        .math-controls {
            display: flex;
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }

        .math-explanation {
            background-color: var(--color-surface);
            border-radius: var(--radius-sm);
            padding: var(--space-md);
            margin-top: var(--space-sm);
            font-size: 13px;
        }

        .math-expression {
            font-family: 'Computer Modern', Georgia, serif;
            background-color: var(--color-surface);
            padding: var(--space-md);
            border-radius: var(--radius-sm);
            margin: var(--space-sm) 0;
            overflow-x: auto;
        }

        /* Expand chat button */
        #expandChatButton {
            background: transparent;
            color: var(--color-secondary-text);
            border: none;
            font-size: 20px;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
        }

        #expandChatButton:hover {
            background: var(--color-hover);
            color: var(--color-primary-text);
        }

        /* Citations Button */
        #citationsButton {
            position: fixed;
            bottom: 24px;
            left: 284px;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            background-color: var(--color-accent-secondary);
            color: #ffffff;
            border-radius: var(--radius-full);
            padding: 0 var(--space-lg);
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.01em;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            white-space: nowrap;
            height: 48px;
            line-height: 48px;
            transition: all var(--transition-normal);
        }

        #citationsButton:hover {
            background-color: #143D28;
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }

        #citationsButton.no-paper {
            display: none !important;
        }

        #citationsButton .material-icons {
            font-size: 20px;
        }

        .citations-count {
            background: var(--color-accent-primary);
            color: white;
            border-radius: var(--radius-full);
            padding: 2px 8px;
            font-size: 11px;
            margin-left: var(--space-xs);
        }

        .citations-count:empty {
            display: none;
        }

        /* Citations Drawer */
        .citations-drawer {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 400px;
            background: var(--color-surface-elevated);
            box-shadow: var(--shadow-lg);
            z-index: 1200;
            display: flex;
            flex-direction: column;
            transform: translateX(-100%);
            transition: transform var(--transition-slow);
            border-right: 1px solid var(--color-border);
        }

        .citations-drawer.visible {
            transform: translateX(0);
        }

        .citations-header {
            padding: var(--space-lg) var(--space-xl);
            background: var(--color-surface-elevated);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .citations-header h3 {
            font-family: var(--font-display);
            margin: 0;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: 18px;
            font-weight: 500;
            color: var(--color-primary-text);
        }

        .citations-header h3 .material-icons {
            font-size: 22px;
            color: var(--color-accent-primary);
        }

        #closeCitationsButton {
            background: transparent;
            color: var(--color-secondary-text);
            border: none;
            padding: var(--space-xs);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            cursor: pointer;
        }

        #closeCitationsButton:hover {
            background: var(--color-hover);
            color: var(--color-primary-text);
        }

        .citations-status {
            padding: var(--space-md) var(--space-xl);
            background: var(--color-surface);
            font-size: 13px;
            color: var(--color-secondary-text);
            border-bottom: 1px solid var(--color-border);
        }

        .citations-status:empty {
            display: none;
        }

        .citations-list {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-lg);
        }

        /* Citation Card */
        .citation-card {
            background: var(--color-surface);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
            border-left: 3px solid var(--color-accent-secondary);
            transition: all var(--transition-fast);
        }

        .citation-card:hover {
            box-shadow: var(--shadow-sm);
            border-left-color: var(--color-accent-primary);
        }

        .citation-card.has-fulltext {
            border-left-color: #2D8A4E;
        }

        .citation-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--color-primary-text);
            margin-bottom: var(--space-sm);
            line-height: 1.5;
        }

        .citation-title a {
            color: var(--color-primary-text);
            text-decoration: none;
        }

        .citation-title a:hover {
            color: var(--color-accent-primary);
        }

        .citation-authors {
            font-size: 12px;
            color: var(--color-secondary-text);
            margin-bottom: var(--space-sm);
        }

        .citation-doi {
            font-size: 11px;
            color: var(--color-tertiary-text);
            font-family: ui-monospace, SFMono-Regular, monospace;
            margin-bottom: var(--space-sm);
            word-break: break-all;
        }

        .citation-abstract {
            font-size: 12px;
            color: var(--color-secondary-text);
            line-height: 1.6;
            margin-bottom: var(--space-sm);
        }

        .citation-abstract.truncated {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .citation-abstract-toggle {
            font-size: 11px;
            color: var(--color-accent-primary);
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
        }

        .citation-abstract-toggle:hover {
            text-decoration: underline;
            background: none;
        }

        .citation-badge {
            display: inline-block;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: var(--radius-full);
            background: #2D8A4E;
            color: white;
            margin-top: var(--space-sm);
            font-weight: 500;
        }

        .citation-year {
            font-size: 12px;
            color: var(--color-tertiary-text);
            font-weight: normal;
        }

        .citation-doi a {
            color: var(--color-accent-primary);
            text-decoration: none;
        }

        .citation-doi a:hover {
            text-decoration: underline;
        }

        .citations-empty {
            text-align: center;
            padding: var(--space-2xl) var(--space-lg);
            color: var(--color-tertiary-text);
        }

        .citations-empty .material-icons {
            font-size: 48px;
            opacity: 0.4;
            margin-bottom: var(--space-md);
        }

        .citations-loading {
            text-align: center;
            padding: var(--space-2xl) var(--space-lg);
            color: var(--color-secondary-text);
        }

        .citations-loading .spinner {
            border: 3px solid var(--color-border);
            border-top-color: var(--color-accent-primary);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 0.8s ease-in-out infinite;
            margin: 0 auto var(--space-md);
        }

        /* AI Provider Select */
        #aiProvider {
            padding: var(--space-sm) var(--space-lg) var(--space-sm) var(--space-md);
            border-radius: var(--radius-full);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            color: var(--color-primary-text);
            height: 40px;
            box-sizing: border-box;
            cursor: pointer;
            font-family: var(--font-body);
            font-weight: 500;
            font-size: 13px;
            transition: all var(--transition-fast);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill=\'%236B6B6F\' height=\'24\' viewBox=\'0 0 24 24\' width=\'24\' xmlns=\'http://www.w3.org/2000/svg\'><path d=\'M7 10l5 5 5-5z\'/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 32px;
        }

        #aiProvider:hover {
            border-color: var(--color-accent-primary);
        }

        #aiProvider:focus {
            outline: none;
            border-color: var(--color-accent-primary);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--color-secondary-text);
        }

        /* Focus states */
        button:focus-visible,
        input:focus-visible,
        textarea:focus-visible,
        select:focus-visible {
            outline: 2px solid var(--color-accent-primary);
            outline-offset: 2px;
        }

        /* Selection styling */
        ::selection {
            background-color: rgba(45, 106, 79, 0.2);
        }
    </style>
    <!-- Include PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js"></script>
    <!-- Add PDF.js text layer CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf_viewer.css">
    <!-- Add marked.js library in the head section -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Sanitize markdown-rendered HTML (prod hardening) -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
</head>

<body>
    <!-- Sidebar for conversation list -->
    <div id="sidebar">
        <div class="sidebar-header">
            <h3>Papers</h3>
            <button id="closeSidebar"><i class="material-icons">chevron_left</i></button>
        </div>
        <div id="conversationList"></div>
    </div>
    <button id="openSidebar"><i class="material-icons">menu</i></button>

    <!-- Main Content Area -->
    <div id="content">
        <div id="topbar">
            <div class="left-section">
                <div class="brand-container">
                    <p class="brand-name">Synopsis AI</p>
                </div>
            </div>
            <form id="uploadForm" method="POST" enctype="multipart/form-data" action="/upload">
                <label class="custom-file-upload">
                    <input type="file" name="pdfFile" accept=".pdf" required />
                    <i class="material-icons">description</i>
                    <span class="label-text">Choose File</span>
                </label>
                <span class="file-name-display"></span>
                <button type="submit">
                    <i class="material-icons">upload</i>
                    Upload
                </button>
                <select id="aiProvider"></select>
                <div id="exportMenuWrap" class="no-paper"
                    style="position: relative; display: inline-flex; align-items: center;">
                    <button id="exportMenuButton" type="button" class="secondary"
                        style="height: 40px; width: 40px; padding: 0; border-radius: var(--radius-full); display:flex; align-items:center; justify-content:center;">
                        <i class="material-icons">download</i>
                    </button>
                    <div id="exportMenu"
                        style="display:none; position:absolute; top: 46px; right:0; background: var(--color-surface-elevated); border: 1px solid var(--color-border); border-radius: 12px; box-shadow: var(--shadow-md); padding: 8px; min-width: 160px; z-index: 2000;">
                        <button id="exportMdButton" type="button" class="secondary"
                            style="width:100%; justify-content:flex-start; gap: 8px;">
                            <i class="material-icons">description</i>
                            Export .md
                        </button>
                        <button id="exportJsonButton" type="button" class="secondary"
                            style="width:100%; justify-content:flex-start; gap: 8px; margin-top: 6px;">
                            <i class="material-icons">data_object</i>
                            Export .json
                        </button>
                    </div>
                </div>
            </form>
        </div>
        <div id="main">
            <!-- Left panel: PDF viewer -->
            <div id="left-panel">
                <div id="uploadPrompt">
                    <!-- <h2>Upload a research paper to get started...</h2> -->
                </div>
                <div id="pdfViewer"></div>
            </div>
            <!-- Right panel: Extraction data and annotations list -->
            <div id="right-panel">
                <h3>Annotations</h3>
                <div id="annotationList"></div>
                <button id="chatButton">
                    <i class="material-icons">chat</i>
                    Chat with Paper
                </button>
            </div>
        </div>
    </div>

    <!-- Annotation Modal for PDF annotations -->
    <div id="annotationModal">
        <div id="annotationModalContent">
            <h3>Add Annotation</h3>
            <p id="annotationPreview"
                style="font-size: 13px; color: var(--color-secondary-text); text-align: center; font-style: italic; margin-bottom: var(--space-md);">
            </p>
            <div id="annotationFiguresPreview" style="margin: 0 auto var(--space-md) auto; width: 90%;"></div>

            <!-- Add hidden select for compatibility -->
            <select id="annotationType" style="display: none;">
                <option value="note" selected>Note</option>
                <option value="question">Question</option>
            </select>

            <div style="display: flex; justify-content: center; gap: 16px; margin-bottom: 16px;">
                <button class="type-selector" data-type="note" onclick="selectAnnotationType('note')">
                    <i class="material-icons">note_add</i>
                    Note
                </button>
                <button class="type-selector" data-type="question" onclick="selectAnnotationType('question')">
                    <i class="material-icons">help_outline</i>
                    Question
                </button>
            </div>

            <div style="text-align: center;">
                <textarea id="annotationText" placeholder="Enter your comment"
                    style="width: 90%; margin: 0 auto;"></textarea>
            </div>

            <div style="text-align: center; margin-top: 16px;">
                <button id="saveAnnotation">Save Annotation</button>
                <button id="cancelAnnotation">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Add selection popup menu -->
    <div id="selectionPopup">
        <button id="addAnnotationBtn">Add annotation</button>
        <button id="explainMathBtn" style="display:none;">Explain math</button>
    </div>

    <div class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing...</div>
    </div>

    <!-- Chat Interface -->
    <div id="chatInterface">
        <div class="chat-header">
            <h3>Chat with Paper</h3>
            <div class="header-buttons">
                <button id="clearChatButton">
                    <i class="material-icons">delete_sweep</i>
                    Clear
                </button>
                <button id="chatScopeButton" class="secondary">
                    <i class="material-icons">layers</i>
                    Scope
                </button>
                <button id="expandChatButton">
                    <i class="material-icons">fullscreen</i>
                </button>
                <button id="closeChatButton"></button>
            </div>
        </div>
        <div id="chatMessages"></div>
        <div class="loading-overlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">AI is thinking...</div>
        </div>
        <div class="chat-input-container">
            <textarea id="chatInput" placeholder="Ask a question about the paper..." rows="1"
                onInput="this.style.height = 'auto'; this.style.height = (this.scrollHeight) + 'px';"></textarea>
            <button id="sendChatButton">Send</button>
        </div>
    </div>

    <!-- Citations Button -->
    <button id="citationsButton" class="no-paper">
        <i class="material-icons">library_books</i>
        References
        <span id="citationsCount" class="citations-count"></span>
    </button>

    <!-- Citations Drawer -->
    <div id="citationsDrawer" class="citations-drawer">
        <div class="citations-header">
            <h3>
                <i class="material-icons">library_books</i>
                References
            </h3>
            <button id="closeCitationsButton">
                <i class="material-icons">close</i>
            </button>
        </div>
        <div
            style="padding: 12px 24px; border-bottom: 1px solid var(--color-border); background: var(--color-surface);">
            <input id="citationsSearch" placeholder="Search title/authors/abstract/DOI/arXiv"
                style="width: 100%; box-sizing: border-box; padding: 10px 12px; border-radius: var(--radius-md); border: 1px solid var(--color-border); background: var(--color-surface-elevated); font-size: 13px;" />
            <div style="display:flex; gap: 10px; margin-top: 10px; align-items:center; flex-wrap: wrap;">
                <select id="citationsTypeFilter"
                    style="flex: 1; min-width: 140px; height: 36px; border-radius: var(--radius-full); border: 1px solid var(--color-border); padding: 0 12px; background: var(--color-surface-elevated);">
                    <option value="all">All types</option>
                    <option value="doi">DOI</option>
                    <option value="arxiv">arXiv</option>
                    <option value="title">Title-only</option>
                </select>
                <select id="citationsYearFilter"
                    style="flex: 1; min-width: 120px; height: 36px; border-radius: var(--radius-full); border: 1px solid var(--color-border); padding: 0 12px; background: var(--color-surface-elevated);">
                    <option value="all">All years</option>
                </select>
                <label
                    style="display:flex; align-items:center; gap: 8px; font-size: 12px; color: var(--color-secondary-text);">
                    <input type="checkbox" id="citationsFullTextOnly" />
                    Full text only
                </label>
            </div>
        </div>
        <div id="citationsStatus" class="citations-status"></div>
        <div id="citationsList" class="citations-list"></div>
    </div>

    <div class="disclaimer">
        This tool can make mistakes. Check important info.
    </div>

    <!-- Add this after the loading overlay -->
    <div id="welcomePanel">
        <h2>Get Started</h2>
        <div class="step-container">
            <div class="step">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h3>Upload Your Paper</h3>
                    <p>Start by uploading a PDF research paper using the upload button in the top bar.</p>
                </div>
            </div>
            <div class="step">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h3>Add Annotations</h3>
                    <p>Select text in the paper to add notes or questions. An AI model can verify your notes or answer
                        your questions about the selected content.</p>
                </div>
            </div>
            <div class="step">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h3>Chat with the Paper</h3>
                    <p>Use the chat feature to ask questions about any aspect of the paper. An AI model will provide
                        answers based on the paper's content and general knowledge.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this before the right panel div -->
    <div id="zoomControls">
        <button onclick="adjustZoom(-0.25)"><i class="material-icons">remove</i></button>
        <span id="zoomLevel">100%</span>
        <button onclick="adjustZoom(0.25)"><i class="material-icons">add</i></button>
    </div>

    <!-- Progress bar container with a label, displayed at bottom left -->
    <div id="progressBarContainer" style="display:none;">
        <div id="progressBar"></div>
        <span id="progressLabel">0%</span>
    </div>

    <script>
        // Global variables for PDF rendering and conversation management.
        const DEBUG = false;
        function log(...args) { if (DEBUG) console.log(...args); }

        function renderMarkdown(md) {
            const html = marked.parse(md || '');
            return window.DOMPurify ? DOMPurify.sanitize(html) : html;
        }

        let pdfDoc = null;
        let currentAnnotations = []; // Annotations for the current PDF.
        let currentPdfUrl = "";
        let conversations = []; // Each conversation: { id, title, pdf_url, extraction, annotations }.
        let currentConversationId = null;
        let currentSelection = null;
        let currentChatHistory = [];
        let currentZoom = 1.5; // Starting zoom level (matches your existing scale)
        let initialZoom = 1.5; // Store initial zoom for reset reference
        let chatScopeUploadIds = []; // Defaults to currentConversationId; can include multiple uploaded papers.

        // Load persistent conversations from the server on page load.
        async function loadPersistentConversations() {
            const res = await fetch("/conversations");
            conversations = await res.json();
            renderSidebar();
            if (conversations.length > 0) {
                loadConversation(conversations[0].id);
            }
        }

        // Persist the conversation list to the server.
        async function persistConversations() {
            await fetch("/conversations", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(conversations)
            });
        }

        // Render the PDF using PDF.js with annotation overlays.
        async function renderPDF(url, annotations) {
            currentPdfUrl = url;
            const viewer = document.getElementById('pdfViewer');
            viewer.innerHTML = "";
            pdfDoc = await pdfjsLib.getDocument(url).promise;

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: currentZoom });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.style.width = viewport.width + "px";
                pageDiv.style.height = viewport.height + "px";
                pageDiv.style.position = "relative";
                pageDiv.dataset.pageNumber = pageNum;

                // Canvas layer
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                pageDiv.appendChild(canvas);

                // Text layer
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'textLayer';
                textLayerDiv.style.width = viewport.width + "px";
                textLayerDiv.style.height = viewport.height + "px";
                pageDiv.appendChild(textLayerDiv);

                viewer.appendChild(pageDiv);

                // Render page content
                const context = canvas.getContext('2d');
                await page.render({ canvasContext: context, viewport: viewport }).promise;

                // Render text layer
                const textContent = await page.getTextContent();
                pdfjsLib.renderTextLayer({
                    textContent: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                });

                // Add event listener to text layer for selection
                textLayerDiv.addEventListener('mouseup', handleTextSelection);

                // Render existing annotation markers
                if (annotations) {
                    annotations.filter(a => a.page === pageNum).forEach(a => {
                        addAnnotationMarker(pageDiv, a);
                    });
                }
            }
            updateZoomDisplay();
        }

        // Update the addAnnotationMarker function to use selection coordinates
        function addAnnotationMarker(pageDiv, annotation) {
            const marker = document.createElement('div');
            marker.className = `annotation-marker ${annotation.type}`; // Add type class
            marker.style.left = annotation.x + "px";
            marker.style.top = annotation.y + "px";
            marker.style.width = annotation.width + "px";
            marker.style.height = annotation.height + "px";
            marker.dataset.annotationId = annotation.id;
            marker.title = annotation.comment;
            pageDiv.appendChild(marker);
        }

        // Open the annotation modal for a given page and coordinate.
        function openAnnotationModal(page, x, y) {
            const modal = document.getElementById('annotationModal');
            modal.style.display = "block";
            modal.dataset.page = page;
            modal.dataset.x = x;
            modal.dataset.y = y;
            document.getElementById('annotationPreview').innerHTML =
                `<strong>Selected text:</strong> "${currentSelection.text}"<br>` +
                `Page ${page} at (${Math.round(x)}, ${Math.round(y)})`;

            // Show nearby figures/captions (if available) and allow insertion into the annotation
            const figuresContainer = document.getElementById('annotationFiguresPreview');
            figuresContainer.innerHTML = '';
            const conv = conversations.find(c => c.id === currentConversationId);
            const figures = conv?.extraction?.pages?.[page - 1]?.figures || [];
            const figuresWithRefs = figures.filter(f => f && f.ref);

            if (figuresWithRefs.length > 0) {
                const header = document.createElement('div');
                header.style.cssText = 'font-size: 11px; color: var(--color-tertiary-text); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px;';
                header.textContent = 'Figures on this page';
                figuresContainer.appendChild(header);

                figuresWithRefs.slice(0, 6).forEach((f) => {
                    const row = document.createElement('div');
                    row.style.cssText = 'background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px; padding: 10px; margin-bottom: 8px;';

                    const title = document.createElement('div');
                    title.style.cssText = 'font-weight: 600; font-size: 12px; margin-bottom: 6px;';
                    title.textContent = f.ref;

                    const caption = document.createElement('div');
                    caption.style.cssText = 'font-size: 12px; color: var(--color-secondary-text); line-height: 1.5; margin-bottom: 8px;';
                    caption.textContent = f.caption || 'No caption found.';

                    const actions = document.createElement('div');
                    actions.style.cssText = 'display:flex; gap: 8px;';

                    const insertBtn = document.createElement('button');
                    insertBtn.className = 'secondary';
                    insertBtn.style.cssText = 'flex:1; font-size: 11px; padding: 6px 10px;';
                    insertBtn.innerHTML = '<i class="material-icons">content_paste</i>Insert caption';
                    insertBtn.addEventListener('click', () => {
                        const ta = document.getElementById('annotationText');
                        const text = f.caption || '';
                        if (!text) return;
                        const prefix = ta.value.trim().length ? '\n\n' : '';
                        ta.value = ta.value + prefix + text;
                        ta.focus();
                    });

                    const chatBtn = document.createElement('button');
                    chatBtn.className = 'secondary';
                    chatBtn.style.cssText = 'flex:1; font-size: 11px; padding: 6px 10px;';
                    chatBtn.innerHTML = '<i class="material-icons">chat</i>Add to chat';
                    chatBtn.addEventListener('click', () => {
                        if (!chatInterface.classList.contains('visible')) chatButton.click();
                        const parts = [`Figure ${f.ref}`];
                        if (f.caption) parts.push(`Caption: ${f.caption}`);
                        if (f.url) parts.push(`Image URL: ${f.url}`);
                        addMessageToChat('system', parts.join('\n'));
                    });

                    actions.appendChild(insertBtn);
                    actions.appendChild(chatBtn);

                    row.appendChild(title);
                    row.appendChild(caption);
                    row.appendChild(actions);
                    figuresContainer.appendChild(row);
                });
            }
        }

        // Cancel annotation modal.
        document.getElementById('cancelAnnotation').addEventListener('click', function () {
            document.getElementById('annotationModal').style.display = "none";
            document.getElementById('annotationText').value = "";
        });

        // Update the saveAnnotation click handler to include dimensions
        document.getElementById('saveAnnotation').addEventListener('click', function () {
            const comment = document.getElementById('annotationText').value.trim();
            if (!comment) {
                alert("Please enter a comment.");
                return;
            }
            const annotationType = document.getElementById('annotationType').value;
            const modal = document.getElementById('annotationModal');
            const page = parseInt(modal.dataset.page);
            const x = parseFloat(modal.dataset.x);
            const y = parseFloat(modal.dataset.y);
            const annotation = {
                id: uuidv4(),
                page,
                x,
                y,
                width: currentSelection.width,   // Include width
                height: currentSelection.height, // Include height
                comment,
                type: annotationType,
                selectedText: currentSelection.text
            };

            if (currentConversationId) {
                const conv = conversations.find(c => c.id === currentConversationId);
                if (conv) {
                    conv.annotations.push(annotation);
                    currentAnnotations = conv.annotations;
                    renderAnnotations(conv.annotations);
                    persistConversations();
                    renderPDF(currentPdfUrl, currentAnnotations);
                }
            }

            modal.style.display = "none";
            document.getElementById('annotationText').value = "";

            // Auto-run AI to reduce clicks
            const createdId = annotation.id;
            const createdType = annotationType;
            setTimeout(() => {
                if (!currentConversationId) return;
                if (createdType === 'note') askAIVerify(createdId);
                if (createdType === 'question') askAIAnswer(createdId);
            }, 50);
        });

        function toggleInlineAI(contentId, buttonEl) {
            const el = document.getElementById(contentId);
            if (!el) return;
            const isHidden = el.style.display === 'none' || !el.style.display;
            el.style.display = isHidden ? 'block' : 'none';
            if (buttonEl) buttonEl.textContent = isHidden ? 'Hide AI' : 'Show AI';
        }

        // Render the annotation list in the right panel.
        function renderAnnotations(annotations) {
            const list = document.getElementById('annotationList');
            list.innerHTML = '';

            if (!annotations || annotations.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.style.cssText = `
                    text-align: center;
                    position: absolute;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    color: black;
                    width: 80%;
                `;
                emptyMessage.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100%;">
                        <i class="material-icons" style="font-size: 48px; opacity: 0.7; margin-bottom: 12px;">annotation</i>
                        <p style="margin: 0 0 8px 0; font-size: 14px; line-height: 1.5; text-align: center;">Select text to annotate</p>
                        <p style="margin: 0; font-size: 12px; line-height: 1.5; text-align: center; opacity: 0.8;">Once text is selected, mark as note or question to use AI to verify or answer your annotation</p>
                    </div>
                `;
                list.appendChild(emptyMessage);
                return;
            }

            annotations.forEach(ann => {
                const div = document.createElement('div');
                div.className = `annotation-item ${ann.type}`;

                const inlineAiId = `inline-ai-${ann.id}`;
                const inlineAiText = ann.type === 'note' ? (ann.aiVerification || '') : (ann.aiAnswer || '');
                const inlineAiLabel = ann.type === 'note' ? 'AI Verification' : 'AI Answer';
                const inlineAiHtml = inlineAiText
                    ? `
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--color-border-light);">
                            <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                                <div style="font-size:11px; color: var(--color-tertiary-text); text-transform: uppercase; letter-spacing: 0.05em;">
                                    ${inlineAiLabel}
                                </div>
                                <button class="secondary" style="font-size:11px; padding: 6px 10px;" onclick="toggleInlineAI('${inlineAiId}', this);">
                                    Show AI
                                </button>
                            </div>
                            <div id="${inlineAiId}" style="display:none; margin-top: 8px; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-sm); padding: var(--space-md);">
                                ${renderMarkdown(inlineAiText)}
                            </div>
                        </div>
                    `
                    : '';

                // Define buttons based on annotation type
                let actionButtons = `
                    <button onclick="scrollToAnnotation('${ann.id}');">
                        <i class="material-icons">location_searching</i>
                        Go to
                    </button>
                `;

                // Add verify button and response viewer for notes
                if (ann.type === 'note') {
                    actionButtons += `
                        <button onclick="askAIVerify('${ann.id}');">
                            <i class="material-icons">verified</i>
                            ${ann.aiVerification ? 'Regenerate' : 'Verify'}
                        </button>
                        ${ann.aiVerification ? `
                            <button onclick="viewAIResponse('${ann.id}', 'verification')">
                                <i class="material-icons">visibility</i>
                                View Verification
                            </button>
                        ` : ''}
                    `;
                }

                // Add answer button and response viewer for questions
                if (ann.type === 'question') {
                    actionButtons += `
                        <button onclick="askAIAnswer('${ann.id}');">
                            <i class="material-icons">question_answer</i>
                            ${ann.aiAnswer ? 'Regenerate' : 'Answer'}
                        </button>
                        ${ann.aiAnswer ? `
                            <button onclick="viewAIResponse('${ann.id}', 'answer')">
                                <i class="material-icons">visibility</i>
                                View Answer
                            </button>
                        ` : ''}
                    `;
                }

                // Add delete button for all types
                actionButtons += `
                    <button onclick="deleteAnnotation('${ann.id}');">
                        <i class="material-icons">delete</i>
                        Delete
                    </button>
                `;

                div.innerHTML = `
                    <div class="metadata">Page ${ann.page}  ${ann.type}</div>
                    <div class="selected-text">"${ann.selectedText}"</div>
                    <div class="comment">${ann.comment}</div>
                    ${inlineAiHtml}
                    <div class="actions">
                        ${actionButtons}
                        <button onclick="addToChat('${ann.id}');">
                            <i class="material-icons">chat</i>
                            Add to Chat
                        </button>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        // AI verification function
        async function askAIVerify(annotationId) {
            showLoading('AI is verifying the annotation...');
            try {
                const provider = getSelectedProvider();
                const conv = conversations.find(c => c.id === currentConversationId);
                if (!conv) {
                    console.error("No conversation found");
                    return;
                }
                const ann = conv.annotations.find(a => a.id === annotationId);
                if (!ann) {
                    console.error("No annotation found");
                    return;
                }

                // Open streaming response modal immediately
                const modal = document.createElement('div');
                modal.className = 'ai-response-modal';
                modal.innerHTML = `
                    <h3>
                        <i class="material-icons">verified</i>
                        AI Verification
                    </h3>
                    <div class="content" id="streamingVerificationContent"></div>
                    <div class="actions">
                        <button id="closeStreamingVerification">
                            <i class="material-icons">close</i>
                            Close
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                modal.querySelector('#closeStreamingVerification').addEventListener('click', () => modal.remove());
                const contentDiv = modal.querySelector('#streamingVerificationContent');

                // Get figures from the current page and surrounding pages
                const pageNum = ann.page;
                const relevantFigures = conv.extraction.pages
                    .filter(p => Math.abs(p.page_number - pageNum) <= 1)
                    .flatMap(p => p.figures.map(f => ({ ...f, page_number: p.page_number })));

                const requestData = {
                    provider: provider,  // Add provider to request
                    uploadId: currentConversationId,  // Add the upload ID
                    selectedText: ann.selectedText,
                    comment: ann.comment,
                    context: conv.extraction.pages[ann.page - 1].text,
                    figures: relevantFigures
                };

                log("Sending verification request with data:", requestData);

                let raw = '';
                let scheduled = false;
                const render = () => {
                    scheduled = false;
                    contentDiv.innerHTML = renderMarkdown(raw);
                };

                await fetchSSE('/verify-annotation/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                }, {
                    onToken: (tok) => {
                        raw += tok;
                        if (!scheduled) {
                            scheduled = true;
                            requestAnimationFrame(render);
                        }
                    },
                    onDone: (fullText) => {
                        const final = fullText || raw;
                        conv.annotations.find(a => a.id === annotationId).aiVerification = final;
                        persistConversations();
                        renderAnnotations(conv.annotations);
                        raw = final;
                        render();
                    },
                    onError: (err) => {
                        contentDiv.textContent = 'Error: ' + err;
                    }
                });
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to verify annotation');
            } finally {
                hideLoading();
            }
        }

        async function askAIAnswer(annotationId) {
            showLoading('AI is analyzing your question...');
            try {
                const provider = getSelectedProvider();
                const conv = conversations.find(c => c.id === currentConversationId);
                if (!conv) {
                    console.error("No conversation found");
                    return;
                }
                const ann = conv.annotations.find(a => a.id === annotationId);
                if (!ann) {
                    console.error("No annotation found");
                    return;
                }

                // Open streaming response modal immediately
                const modal = document.createElement('div');
                modal.className = 'ai-response-modal';
                modal.innerHTML = `
                    <h3>
                        <i class="material-icons">question_answer</i>
                        AI Answer
                    </h3>
                    <div class="content" id="streamingAnswerContent"></div>
                    <div class="actions">
                        <button id="closeStreamingAnswer">
                            <i class="material-icons">close</i>
                            Close
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                modal.querySelector('#closeStreamingAnswer').addEventListener('click', () => modal.remove());
                const contentDiv = modal.querySelector('#streamingAnswerContent');

                // Get figures from the current page and surrounding pages
                const pageNum = ann.page;
                const relevantFigures = conv.extraction.pages
                    .filter(p => Math.abs(p.page_number - pageNum) <= 1)
                    .flatMap(p => p.figures.map(f => ({ ...f, page_number: p.page_number })));

                const requestData = {
                    provider: provider,  // Add provider to request
                    uploadId: currentConversationId,  // Add the upload ID
                    selectedText: ann.selectedText,
                    question: ann.comment,
                    context: conv.extraction.pages[ann.page - 1].text,
                    figures: relevantFigures
                };

                log("Sending answer request with data:", requestData);

                let raw = '';
                let scheduled = false;
                const render = () => {
                    scheduled = false;
                    contentDiv.innerHTML = renderMarkdown(raw);
                };

                await fetchSSE('/answer-question/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                }, {
                    onToken: (tok) => {
                        raw += tok;
                        if (!scheduled) {
                            scheduled = true;
                            requestAnimationFrame(render);
                        }
                    },
                    onDone: (fullText) => {
                        const final = fullText || raw;
                        conv.annotations.find(a => a.id === annotationId).aiAnswer = final;
                        persistConversations();
                        renderAnnotations(conv.annotations);
                        raw = final;
                        render();
                    },
                    onError: (err) => {
                        contentDiv.textContent = 'Error: ' + err;
                    }
                });
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to get AI answer');
            } finally {
                hideLoading();
            }
        }

        // Delete an annotation.
        function deleteAnnotation(annId) {
            const conv = conversations.find(c => c.id === currentConversationId);
            if (conv) {
                conv.annotations = conv.annotations.filter(a => a.id !== annId);
                currentAnnotations = conv.annotations;
                renderAnnotations(conv.annotations);
                renderPDF(currentPdfUrl, currentAnnotations);
                persistConversations();
            }
        }

        // Sidebar and conversation management.
        function renderSidebar() {
            const list = document.getElementById('conversationList');
            list.innerHTML = '';
            conversations.forEach(conv => {
                const item = document.createElement('div');
                item.className = 'conversation-item';
                item.dataset.id = conv.id;
                item.innerHTML = `<span>${conv.title}</span> <button onclick="deleteConversation('${conv.id}'); event.stopPropagation();">Delete</button>`;
                item.addEventListener('click', function () {
                    loadConversation(conv.id);
                });
                list.appendChild(item);
            });
        }

        function loadConversation(id) {
            const conv = conversations.find(c => c.id === id);
            if (conv) {
                currentConversationId = id;
                chatScopeUploadIds = [id];
                currentAnnotations = conv.annotations || [];
                renderPDF(conv.pdf_url, currentAnnotations);
                renderAnnotations(conv.annotations);
                loadChatHistory(id);
                document.getElementById('uploadPrompt').style.display = 'none';
                document.getElementById('welcomePanel').style.display = 'none';

                // Remove no-paper class from elements
                document.getElementById('sidebar').classList.remove('no-paper');
                document.getElementById('right-panel').classList.remove('no-paper');
                document.getElementById('chatButton').classList.remove('no-paper');
                document.getElementById('citationsButton').classList.remove('no-paper');
                document.getElementById('exportMenuWrap').classList.remove('no-paper');
                document.getElementById('content').classList.remove('no-paper');
                document.getElementById('main').classList.remove('no-paper');
                document.getElementById('zoomControls').classList.remove('no-paper');
                document.getElementById('zoomControls').style.display = 'flex';

                document.getElementById('chatButton').classList.remove('disabled');
            }
        }

        function deleteConversation(id) {
            const conv = conversations.find(c => c.id === id);
            if (conv) {
                fetch(`/delete-upload/${id}`, {
                    method: 'POST'
                });

                conversations = conversations.filter(c => c.id !== id);
                if (currentConversationId === id) {
                    // Clear the PDF viewer more thoroughly
                    const pdfViewer = document.getElementById('pdfViewer');
                    pdfViewer.innerHTML = "";
                    pdfViewer.style.display = 'none';

                    // Close and clear chat interface
                    closeChatInterface();
                    currentChatHistory = [];
                    document.getElementById('chatMessages').innerHTML = "";

                    document.getElementById('annotationList').innerHTML = "";
                    currentConversationId = null;

                    // Show welcome panel and add no-paper class to elements
                    document.getElementById('welcomePanel').style.display = 'block';
                    document.getElementById('uploadPrompt').style.display = 'block';
                    document.getElementById('sidebar').classList.add('no-paper');
                    document.getElementById('right-panel').classList.add('no-paper');
                    document.getElementById('chatButton').classList.add('no-paper');
                    document.getElementById('citationsButton').classList.add('no-paper');
                    document.getElementById('exportMenuWrap').classList.add('no-paper');
                    document.getElementById('content').classList.add('no-paper');
                    document.getElementById('main').classList.add('no-paper');
                    document.getElementById('zoomControls').classList.add('no-paper');
                    document.getElementById('zoomControls').style.display = 'none';

                    // Close citations drawer
                    document.getElementById('citationsDrawer').classList.remove('visible');
                    document.getElementById('citationsCount').textContent = '';

                    document.getElementById('chatButton').classList.add('disabled');
                }
                renderSidebar();
                persistConversations();
            }
        }

        // Add new helper function to close chat interface
        function closeChatInterface() {
            const chatInterface = document.getElementById('chatInterface');
            const chatButton = document.getElementById('chatButton');

            chatInterface.classList.remove('visible');
            setTimeout(() => {
                chatInterface.style.display = 'none';
            }, 300);
            chatButton.style.display = 'flex';
        }

        document.getElementById('uploadForm').addEventListener('submit', async function (e) {
            e.preventDefault();

            // Show progress bar
            const progressBarContainer = document.getElementById("progressBarContainer");
            const progressBar = document.getElementById("progressBar");
            const progressLabel = document.getElementById("progressLabel");
            progressBarContainer.style.display = "block";
            progressBar.style.width = "0%";
            progressLabel.textContent = "0%";

            const formData = new FormData(this);
            try {
                const response = await fetch('/upload', { method: 'POST', body: formData });
                if (!response.ok) {
                    throw new Error("Error uploading PDF");
                }
                const data = await response.json();

                // Create and display the conversation immediately with the PDF
                const conv = {
                    id: data.upload_id,
                    title: formData.get("pdfFile").name,
                    pdf_url: data.pdf_url,
                    extraction: data.extraction,
                    annotations: [],
                    citations: [] // Will be updated when background task completes
                };
                conversations.push(conv);
                renderSidebar();

                // Load the conversation and render the PDF immediately
                await loadConversation(conv.id);
                persistConversations();

                // Start polling for progress in background
                const taskId = data.task_id;
                const pollInterval = setInterval(async () => {
                    const progressResponse = await fetch(`/task-progress/${taskId}`);
                    const progressData = await progressResponse.json();

                    if (progressData.error) {
                        clearInterval(pollInterval);
                        throw new Error(progressData.error);
                    }

                    // Update progress bar
                    progressBar.style.width = `${progressData.progress}%`;
                    progressLabel.textContent = `${progressData.status} (${progressData.progress}%)`;

                    if (progressData.complete) {
                        clearInterval(pollInterval);

                        // Update the conversation with citations from the background task
                        conv.citations = progressData.result;
                        persistConversations();

                        // Hide progress after a brief delay
                        setTimeout(() => {
                            progressBarContainer.style.display = "none";
                        }, 500);
                    }
                }, 1000); // Poll every second

                // Reset file input UI state
                this.reset();
                const fileLabel = document.querySelector('.custom-file-upload');
                const fileNameDisplay = document.querySelector('.file-name-display');
                fileLabel.classList.remove('file-selected');
                fileNameDisplay.classList.remove('visible');
                fileNameDisplay.textContent = '';
                fileLabel.querySelector('.label-text').textContent = 'Choose File';
                document.getElementById('welcomePanel').style.display = 'none';

            } catch (error) {
                console.error("Upload error:", error);
                alert("Error uploading PDF: " + error.message);
                progressBarContainer.style.display = "none";
            }
        });

        // Sidebar toggle functionality.
        document.getElementById('closeSidebar').addEventListener('click', function () {
            document.getElementById('sidebar').classList.add('closed');
            document.getElementById('openSidebar').style.display = 'flex';
        });
        document.getElementById('openSidebar').addEventListener('click', function () {
            document.getElementById('sidebar').classList.remove('closed');
            document.getElementById('openSidebar').style.display = 'none';
        });

        // Simple UUID generator.
        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Load persistent conversations when the page loads.
        window.onload = function () {
            loadPersistentConversations();
            loadAIProviders();

            // Show welcome panel and hide elements if no paper is displayed
            if (conversations.length === 0 || !currentConversationId) {
                document.getElementById('uploadPrompt').style.display = 'block';
                document.getElementById('chatButton').classList.add('disabled');
                document.getElementById('welcomePanel').style.display = 'block';

                // Add no-paper class to elements
                document.getElementById('sidebar').classList.add('no-paper');
                document.getElementById('right-panel').classList.add('no-paper');
                document.getElementById('chatButton').classList.add('no-paper');
                document.getElementById('citationsButton').classList.add('no-paper');
                document.getElementById('exportMenuWrap').classList.add('no-paper');
                document.getElementById('content').classList.add('no-paper');
                document.getElementById('main').classList.add('no-paper');
                document.getElementById('zoomControls').classList.add('no-paper');
                document.getElementById('zoomControls').style.display = 'none';
            }
        }

        // Update the handleTextSelection function to capture selection dimensions
        function handleTextSelection(event) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (!selectedText) {
                document.getElementById('selectionPopup').style.display = 'none';
                return;
            }

            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const popup = document.getElementById('selectionPopup');

            popup.style.display = 'block';
            popup.style.left = `${rect.left + window.scrollX}px`;
            popup.style.top = `${rect.bottom + window.scrollY}px`;

            const pageDiv = event.target.closest('.pdf-page');
            const pageRect = pageDiv.getBoundingClientRect();

            currentSelection = {
                text: selectedText,
                page: parseInt(pageDiv.dataset.pageNumber),
                x: rect.left - pageRect.left,
                y: rect.top - pageRect.top,
                width: rect.width,   // Add width of selection
                height: rect.height  // Add height of selection
            };

            const mathBtn = document.getElementById('explainMathBtn');
            const looksMathy = /[=^_\\]/.test(selectedText) || /\b\d+\s*\/\s*\d+\b/.test(selectedText);
            mathBtn.style.display = looksMathy ? 'inline-flex' : 'none';
        }

        // Add selection popup button handler
        document.getElementById('addAnnotationBtn').addEventListener('click', function () {
            if (currentSelection) {
                openAnnotationModal(
                    currentSelection.page,
                    currentSelection.x,
                    currentSelection.y
                );
                document.getElementById('selectionPopup').style.display = 'none';
            }
        });

        document.getElementById('explainMathBtn').addEventListener('click', async function () {
            if (!currentSelection || !currentConversationId) return;
            document.getElementById('selectionPopup').style.display = 'none';

            const provider = getSelectedProvider();
            const conv = conversations.find(c => c.id === currentConversationId);
            const pageNum = currentSelection.page;

            const modal = document.createElement('div');
            modal.className = 'ai-response-modal';
            modal.innerHTML = `
                <h3>
                    <i class="material-icons">functions</i>
                    Math Explanation
                </h3>
                <div class="content" id="streamingMathContent"></div>
                <div class="actions">
                    <button onclick="this.closest('.ai-response-modal').remove()">
                        <i class="material-icons">close</i>
                        Close
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            const contentDiv = modal.querySelector('#streamingMathContent');

            const requestData = {
                provider,
                uploadId: currentConversationId,
                expression: currentSelection.text,
                context: conv?.extraction?.pages?.[pageNum - 1]?.text || '',
                paper_context: conv?.extraction || {}
            };

            showLoading('Explaining math...');
            let raw = '';
            let scheduled = false;
            const render = () => {
                scheduled = false;
                contentDiv.innerHTML = renderMarkdown(raw);
            };

            try {
                await fetchSSE('/explain-math/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                }, {
                    onToken: (tok) => {
                        raw += tok;
                        if (!scheduled) {
                            scheduled = true;
                            requestAnimationFrame(render);
                        }
                    },
                    onDone: (fullText) => {
                        raw = fullText || raw;
                        render();
                    },
                    onError: (err) => {
                        contentDiv.textContent = 'Error: ' + err;
                    }
                });
            } finally {
                hideLoading();
            }
        });

        // Close selection popup when clicking outside
        document.addEventListener('mousedown', function (event) {
            if (!event.target.closest('#selectionPopup')) {
                document.getElementById('selectionPopup').style.display = 'none';
            }
        });

        function showLoading(message = 'Processing...') {
            // For chat-specific loading, use the loading overlay inside chat interface
            if (message === 'AI is thinking...') {
                const chatOverlay = document.querySelector('#chatInterface .loading-overlay');
                const text = chatOverlay.querySelector('.loading-text');
                text.textContent = message;
                chatOverlay.style.display = 'flex';
            } else {
                // For other loading scenarios, use the main loading overlay
                const overlay = document.querySelector('body > .loading-overlay');
                const text = overlay.querySelector('.loading-text');
                text.textContent = message;
                overlay.style.display = 'flex';
            }
        }

        function hideLoading() {
            // Hide both loading overlays
            document.querySelectorAll('.loading-overlay').forEach(overlay => {
                overlay.style.display = 'none';
            });
        }

        // Chat functionality
        const chatButton = document.getElementById('chatButton');
        const chatInterface = document.getElementById('chatInterface');
        const closeChatButton = document.getElementById('closeChatButton');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');
        const chatScopeButton = document.getElementById('chatScopeButton');
        const exportMenuWrap = document.getElementById('exportMenuWrap');
        const exportMenuButton = document.getElementById('exportMenuButton');
        const exportMenu = document.getElementById('exportMenu');
        const exportMdButton = document.getElementById('exportMdButton');
        const exportJsonButton = document.getElementById('exportJsonButton');

        function toggleExportMenu(show) {
            if (!exportMenu) return;
            const shouldShow = show !== undefined ? show : (exportMenu.style.display === 'none' || !exportMenu.style.display);
            exportMenu.style.display = shouldShow ? 'block' : 'none';
        }

        exportMenuButton?.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleExportMenu();
        });

        document.addEventListener('click', (e) => {
            if (exportMenu && exportMenu.style.display === 'block') {
                if (!exportMenuWrap.contains(e.target)) toggleExportMenu(false);
            }
        });

        function triggerExport(fmt) {
            if (!currentConversationId) return;
            window.location.href = `/export/${currentConversationId}?format=${encodeURIComponent(fmt)}`;
            toggleExportMenu(false);
        }

        exportMdButton?.addEventListener('click', () => triggerExport('md'));
        exportJsonButton?.addEventListener('click', () => triggerExport('json'));

        // Chat scope selector: choose which uploaded papers are included in retrieval.
        chatScopeButton?.addEventListener('click', () => {
            if (!conversations || conversations.length === 0) return;
            const selected = new Set(chatScopeUploadIds && chatScopeUploadIds.length ? chatScopeUploadIds : (currentConversationId ? [currentConversationId] : []));

            const modal = document.createElement('div');
            modal.className = 'ai-response-modal';
            modal.innerHTML = `
                <h3>
                    <i class="material-icons">layers</i>
                    Chat Scope
                </h3>
                <div class="content" style="background: var(--color-background);">
                    <p style="margin-top:0; color: var(--color-secondary-text); font-size: 13px;">
                        Select uploaded papers to include in chat retrieval.
                    </p>
                    <div id="scopeList" style="display:flex; flex-direction:column; gap: 10px;"></div>
                </div>
                <div class="actions">
                    <button id="scopeUseCurrent" class="secondary">
                        <i class="material-icons">filter_1</i>
                        Current only
                    </button>
                    <button id="scopeSave">
                        <i class="material-icons">check</i>
                        Save
                    </button>
                    <button id="scopeClose" class="secondary">
                        <i class="material-icons">close</i>
                        Close
                    </button>
                </div>
            `;
            document.body.appendChild(modal);

            const scopeList = modal.querySelector('#scopeList');
            conversations.forEach(c => {
                const row = document.createElement('label');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '10px';
                row.style.padding = '10px';
                row.style.border = '1px solid var(--color-border)';
                row.style.borderRadius = '12px';
                row.style.background = 'var(--color-surface-elevated)';
                row.innerHTML = `
                    <input type="checkbox" ${selected.has(c.id) ? 'checked' : ''} data-upload-id="${c.id}" />
                    <div style="display:flex; flex-direction:column;">
                        <div style="font-weight:600; font-size: 13px;">${escapeHtml(c.title || c.id)}</div>
                        <div style="font-size: 12px; color: var(--color-secondary-text);">${escapeHtml(c.id)}</div>
                    </div>
                `;
                scopeList.appendChild(row);
            });

            modal.querySelector('#scopeClose').addEventListener('click', () => modal.remove());
            modal.querySelector('#scopeUseCurrent').addEventListener('click', () => {
                chatScopeUploadIds = currentConversationId ? [currentConversationId] : [];
                modal.remove();
            });
            modal.querySelector('#scopeSave').addEventListener('click', () => {
                const ids = Array.from(modal.querySelectorAll('input[type=\"checkbox\"][data-upload-id]'))
                    .filter(cb => cb.checked)
                    .map(cb => cb.getAttribute('data-upload-id'));
                chatScopeUploadIds = ids.length ? ids : (currentConversationId ? [currentConversationId] : []);
                modal.remove();
            });
        });

        chatButton.addEventListener('click', () => {
            chatInterface.style.display = 'flex';
            // Small delay to trigger animation
            setTimeout(() => {
                chatInterface.classList.add('visible');
            }, 10);
            chatButton.style.display = 'none';
        });

        closeChatButton.addEventListener('click', () => {
            chatInterface.classList.remove('visible');
            // Wait for animation to complete before hiding
            setTimeout(() => {
                chatInterface.style.display = 'none';
            }, 300);
            chatButton.style.display = 'flex';
        });

        async function fetchSSE(url, options, handlers) {
            const response = await fetch(url, options);
            if (!response.ok) {
                let msg = `${response.status} ${response.statusText}`;
                try {
                    const j = await response.json();
                    if (j && j.error) msg = j.error;
                } catch (_) { }
                throw new Error(msg);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                const parts = buffer.split('\n\n');
                buffer = parts.pop() || '';

                for (const part of parts) {
                    const lines = part.split('\n').filter(Boolean);
                    let event = 'message';
                    let dataLines = [];
                    for (const line of lines) {
                        if (line.startsWith('event:')) event = line.slice(6).trim();
                        if (line.startsWith('data:')) dataLines.push(line.slice(5).trim());
                    }
                    const dataStr = dataLines.join('\n');
                    let data = {};
                    try { data = JSON.parse(dataStr); } catch (_) { data = { raw: dataStr }; }

                    if (event === 'token' && handlers?.onToken) handlers.onToken(data.token || '');
                    if (event === 'done' && handlers?.onDone) handlers.onDone(data.text || '');
                    if (event === 'error' && handlers?.onError) handlers.onError(data.error || 'Unknown error');
                    if (event === 'start' && handlers?.onStart) handlers.onStart(data);
                }
            }
        }

        function addStreamingAIMessage() {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message ai-message';
            messageDiv.innerHTML = '';
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            let raw = '';
            let scheduled = false;
            const render = () => {
                scheduled = false;
                messageDiv.innerHTML = renderMarkdown(raw);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            };

            return {
                appendToken: (t) => {
                    raw += t;
                    if (!scheduled) {
                        scheduled = true;
                        requestAnimationFrame(render);
                    }
                },
                finalize: () => raw,
            };
        }

        async function sendChatMessage(message) {
            if (!currentConversationId) {
                alert('Please upload a paper first');
                return;
            }

            addMessageToChat('user', message);
            // Streaming renders tokens immediately; avoid flashing a loading overlay.

            try {
                const provider = getSelectedProvider();
                const conv = conversations.find(c => c.id === currentConversationId);

                // Format annotations context
                const annotationsContext = conv.annotations.map(ann => {
                    let context = `Selected Text: "${ann.selectedText}"\n`;
                    context += `${ann.type === 'note' ? 'Note' : 'Question'}: ${ann.comment}\n`;
                    if (ann.aiVerification) {
                        context += `AI Verification: ${ann.aiVerification}\n`;
                    }
                    if (ann.aiAnswer) {
                        context += `AI Answer: ${ann.aiAnswer}\n`;
                    }
                    return context;
                }).join('\n---\n');

                const requestData = {
                    message: message,
                    provider: provider,
                    uploadId: currentConversationId,  // Add the upload ID
                    uploadIds: (chatScopeUploadIds && chatScopeUploadIds.length ? chatScopeUploadIds : [currentConversationId]),
                    paper_context: conversations.find(c => c.id === currentConversationId).extraction,
                    annotations_context: annotationsContext
                };

                const streaming = addStreamingAIMessage();
                const multi = requestData.uploadIds && requestData.uploadIds.length > 1;
                const streamUrl = multi ? '/chat-multi/stream' : '/chat-with-paper/stream';

                await fetchSSE(streamUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                }, {
                    onToken: (tok) => streaming.appendToken(tok),
                    onDone: (fullText) => {
                        const final = fullText || streaming.finalize();
                        currentChatHistory.push({ role: 'ai', content: final });
                        saveChatHistory();
                    },
                    onError: (err) => {
                        addMessageToChat('system', 'Error: ' + err);
                    }
                });
            } catch (error) {
                console.error('Error:', error);
                addMessageToChat('system', 'Error: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        function addMessageToChat(role, content, save = true) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}-message`;

            // Use marked to parse markdown for AI messages
            if (role === 'ai') {
                messageDiv.innerHTML = renderMarkdown(content);
            } else {
                messageDiv.textContent = content;
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            if (save) {
                currentChatHistory.push({ role, content });
                saveChatHistory();
            }
        }

        sendChatButton.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message) {
                sendChatMessage(message);
                chatInput.value = '';
            }
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatButton.click();
            }
        });

        // Add new function to load chat history
        async function loadChatHistory(conversationId) {
            try {
                const response = await fetch(`/chat-history/${conversationId}`);
                currentChatHistory = await response.json();
                renderChatHistory();
            } catch (error) {
                console.error('Error loading chat history:', error);
                currentChatHistory = [];
            }
        }

        // Add function to render chat history
        function renderChatHistory() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            currentChatHistory.forEach(msg => {
                addMessageToChat(msg.role, msg.content, false);
            });
        }

        // Add function to save chat history
        async function saveChatHistory() {
            if (!currentConversationId) return;

            try {
                await fetch(`/chat-history/${currentConversationId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(currentChatHistory)
                });
            } catch (error) {
                console.error('Error saving chat history:', error);
            }
        }

        // Add file selection handler
        document.querySelector('input[type="file"]').addEventListener('change', function (e) {
            const fileName = e.target.files[0]?.name;
            const fileLabel = e.target.closest('.custom-file-upload');
            const fileNameDisplay = document.querySelector('.file-name-display');

            if (fileName) {
                fileLabel.classList.add('file-selected');
                fileNameDisplay.textContent = fileName;
                fileNameDisplay.classList.add('visible');
                fileLabel.querySelector('.label-text').textContent = 'File Selected';
            } else {
                fileLabel.classList.remove('file-selected');
                fileNameDisplay.classList.remove('visible');
                fileLabel.querySelector('.label-text').textContent = 'Choose File';
            }
        });

        // Update the scrollToAnnotation function to account for zoom
        function scrollToAnnotation(annotationId) {
            const conv = conversations.find(c => c.id === currentConversationId);
            if (!conv) return;

            const annotation = conv.annotations.find(a => a.id === annotationId);
            if (!annotation) return;

            const pageDiv = document.querySelector(`.pdf-page[data-page-number="${annotation.page}"]`);
            if (!pageDiv) return;

            // Calculate the scaled position
            const scaledY = (annotation.y * currentZoom) + pageDiv.offsetTop;

            // Scroll the page into view with the scaled position
            document.getElementById('left-panel').scrollTo({
                top: scaledY - window.innerHeight / 2,
                behavior: 'smooth'
            });

            // Flash the annotation marker with type-specific color
            const marker = pageDiv.querySelector(`.annotation-marker[data-annotation-id="${annotationId}"]`);
            if (marker) {
                marker.style.transition = 'all 0.3s ease';
                marker.style.transform = 'scale(1.5)';

                // Set highlight color based on annotation type
                if (annotation.type === 'note') {
                    marker.style.background = 'rgba(26, 54, 93, 0.8)'; // #1a365d
                } else if (annotation.type === 'question') {
                    marker.style.background = 'rgba(128, 0, 32, 0.8)'; // #800020
                }

                setTimeout(() => {
                    marker.style.transform = 'scale(1)';
                    // Reset to original transparency
                    if (annotation.type === 'note') {
                        marker.style.background = 'rgba(26, 54, 93, 0.3)';
                    } else if (annotation.type === 'question') {
                        marker.style.background = 'rgba(128, 0, 32, 0.3)';
                    }
                }, 1000);
            }
        }

        // Add this after window.onload
        async function loadAIProviders() {
            try {
                const response = await fetch('/ai-providers');
                const data = await response.json();
                const select = document.getElementById('aiProvider');
                select.innerHTML = ''; // Clear existing options

                // Add available providers from the backend
                data.providers.forEach(provider => {
                    const option = document.createElement('option');
                    option.value = provider.id;
                    option.textContent = provider.name;
                    option.disabled = !provider.enabled;
                    select.appendChild(option);
                });

                // If no providers are available, add a default disabled option
                if (data.providers.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = 'No AI providers available';
                    option.disabled = true;
                    select.appendChild(option);
                }
            } catch (error) {
                console.error('Error loading AI providers:', error);
            }
        }

        // Update the existing functions to include the selected provider
        function getSelectedProvider() {
            return document.getElementById('aiProvider').value;
        }

        // Add new function to view AI responses
        function viewAIResponse(annotationId, type) {
            const conv = conversations.find(c => c.id === currentConversationId);
            const ann = conv.annotations.find(a => a.id === annotationId);

            if (!ann) return;

            const response = type === 'verification' ? ann.aiVerification : ann.aiAnswer;
            if (!response) return;

            // Create modal HTML with enhanced styling and section organization
            const modalHtml = `
                <div class="ai-response-modal">
                    <h3>
                        <i class="material-icons">${type === 'verification' ? 'verified' : 'question_answer'}</i>
                        AI ${type === 'verification' ? 'Verification' : 'Answer'}
                    </h3>
                    <div class="content">
                        ${formatAIResponse(response)}
                    </div>
                    <div class="actions">
                        <button onclick="this.closest('.ai-response-modal').remove()">
                            <i class="material-icons">close</i>
                            Close
                        </button>
                        <button onclick="if(confirm('Regenerate response?')) { ${type === 'verification' ? 'askAIVerify' : 'askAIAnswer'}('${annotationId}'); this.closest('.ai-response-modal').remove(); }">
                            <i class="material-icons">refresh</i>
                            Regenerate
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function formatAIResponse(response) {
            // Parse the markdown content
            let html = renderMarkdown(response);

            // Add section styling and icons
            html = html.replace(/<h2>Answer:/g, '<div class="response-section"><h3><i class="material-icons section-icon">lightbulb</i>Answer:</h3>');
            html = html.replace(/<h2>Paper Evidence:/g, '<div class="response-section"><h3><i class="material-icons section-icon">description</i>Paper Evidence:</h3>');
            html = html.replace(/<h2>Web Sources:/g, '<div class="response-section"><h3><i class="material-icons section-icon">public</i>Web Sources:</h3>');
            html = html.replace(/<h2>General Knowledge:/g, '<div class="response-section"><h3><i class="material-icons section-icon">psychology</i>General Knowledge:</h3>');

            // Add closing div for sections
            html = html.replace(/<h2>/g, '</div><h2>');

            // Style web citations
            html = html.replace(
                /\[(.*?)\]\((https?:\/\/[^\s\)]+)\)/g,
                '<div class="web-citation"> <a href="$2" target="_blank">$1</a></div>'
            );

            // Style paper quotes
            html = html.replace(
                /(".*?")\s*from the paper/g,
                '<div class="paper-citation">$1</div>'
            );

            return html;
        }

        // Update loading state display
        function showAILoading() {
            return `
                <div class="ai-response-loading">
                    <div class="spinner"></div>
                    <p>Processing request...</p>
                </div>
            `;
        }

        // Add clear chat functionality
        document.getElementById('clearChatButton').addEventListener('click', async () => {
            if (confirm('Are you sure you want to clear the chat history?')) {
                currentChatHistory = [];
                document.getElementById('chatMessages').innerHTML = '';

                // Save empty chat history to server
                if (currentConversationId) {
                    try {
                        await fetch(`/chat-history/${currentConversationId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify([])
                        });
                    } catch (error) {
                        console.error('Error clearing chat history:', error);
                    }
                }
            }
        });

        // Add this function
        function selectAnnotationType(type) {
            // Update buttons
            document.querySelectorAll('.type-selector').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.type === type) {
                    btn.classList.add('selected');
                }
            });

            // Update hidden select value
            document.getElementById('annotationType').value = type;
        }

        // Add this to initialize the UI when modal opens
        document.getElementById('addAnnotationBtn').addEventListener('click', function () {
            if (currentSelection) {
                openAnnotationModal(
                    currentSelection.page,
                    currentSelection.x,
                    currentSelection.y
                );
                // Select default type (note)
                selectAnnotationType('note');
                document.getElementById('selectionPopup').style.display = 'none';
            }
        });

        // Add these new functions
        function adjustZoom(delta) {
            const newZoom = currentZoom + delta;
            if (newZoom >= 0.5 && newZoom <= 3) { // Limit zoom range
                currentZoom = newZoom;
                renderPDF(currentPdfUrl, currentAnnotations);
            }
        }

        function updateZoomDisplay() {
            const percentage = Math.round(currentZoom * 100);
            document.getElementById('zoomLevel').textContent = `${percentage}%`;
        }

        // Add this function to check task status on page load
        async function checkExistingTasks() {
            // Get all conversations
            const conversations = await fetch('/conversations').then(r => r.json());

            // Check each conversation for incomplete tasks
            for (const conv of conversations) {
                const taskId = conv.id; // Using conversation id as task id
                try {
                    const progressResponse = await fetch(`/task-progress/${taskId}`);
                    const progressData = await progressResponse.json();

                    if (!progressData.complete) {
                        // Show and update progress bar
                        const progressBarContainer = document.getElementById("progressBarContainer");
                        const progressBar = document.getElementById("progressBar");
                        const progressLabel = document.getElementById("progressLabel");
                        progressBarContainer.style.display = "block";
                        progressBar.style.width = `${progressData.progress}%`;
                        progressLabel.textContent = `${progressData.status} (${progressData.progress}%)`;

                        // Start polling for this task
                        startProgressPolling(taskId, conv);
                    }
                } catch (error) {
                    console.error(`Error checking task ${taskId}:`, error);
                }
            }
        }

        // Extract polling logic to separate function
        function startProgressPolling(taskId, conv) {
            const progressBarContainer = document.getElementById("progressBarContainer");
            const progressBar = document.getElementById("progressBar");
            const progressLabel = document.getElementById("progressLabel");

            const pollInterval = setInterval(async () => {
                try {
                    const progressResponse = await fetch(`/task-progress/${taskId}`);
                    const progressData = await progressResponse.json();

                    if (progressData.error) {
                        clearInterval(pollInterval);
                        throw new Error(progressData.error);
                    }

                    // Update progress bar
                    progressBar.style.width = `${progressData.progress}%`;
                    progressLabel.textContent = `${progressData.status} (${progressData.progress}%)`;

                    if (progressData.complete) {
                        clearInterval(pollInterval);

                        // Update the conversation with citations from the background task
                        conv.citations = progressData.result;
                        persistConversations();

                        // Hide progress after a brief delay
                        setTimeout(() => {
                            progressBarContainer.style.display = "none";
                        }, 500);
                    }
                } catch (error) {
                    console.error("Progress polling error:", error);
                    clearInterval(pollInterval);
                }
            }, 1000);
        }

        // Modify the upload form handler to use the new polling function
        document.getElementById('uploadForm').addEventListener('submit', async function (e) {
            // ... existing code until conversation creation ...

            // Start polling for progress in background
            startProgressPolling(data.task_id, conv);

            // ... rest of existing code ...
        });

        // Add this to your initialization code (e.g., at the end of the file or in DOMContentLoaded)
        document.addEventListener('DOMContentLoaded', function () {
            checkExistingTasks();
        });

        // Add this function to handle adding annotations to chat
        function addToChat(annotationId) {
            const conv = conversations.find(c => c.id === currentConversationId);
            const ann = conv.annotations.find(a => a.id === annotationId);

            if (!ann) return;

            // Open chat if not already open
            if (!chatInterface.classList.contains('visible')) {
                chatButton.click();
            }

            // Add annotation to chat as system message
            let messageContent = `**Selected Text:** "${ann.selectedText}"\n\n`;
            messageContent += `**${ann.type === 'note' ? 'Note' : 'Question'}:** ${ann.comment}\n\n`;

            // Add verification/answer if available
            if (ann.aiVerification) {
                messageContent += `**AI Verification:**\n${ann.aiVerification}\n\n`;
            }
            if (ann.aiAnswer) {
                messageContent += `**AI Answer:**\n${ann.aiAnswer}\n\n`;
            }

            addMessageToChat('system', messageContent);

            // Focus chat input
            chatInput.focus();
        }

        // Add this JavaScript code after the existing chat interface code
        const expandChatButton = document.getElementById('expandChatButton');
        let isExpanded = false;

        expandChatButton.addEventListener('click', () => {
            isExpanded = !isExpanded;
            chatInterface.classList.toggle('expanded');

            // Update icon based on state
            expandChatButton.querySelector('.material-icons').textContent =
                isExpanded ? 'fullscreen_exit' : 'fullscreen';

            // Save the current dimensions before expanding
            if (isExpanded) {
                chatInterface.dataset.prevWidth = chatInterface.style.width;
                chatInterface.dataset.prevHeight = chatInterface.style.height;
            } else {
                // Restore previous dimensions
                chatInterface.style.width = chatInterface.dataset.prevWidth || '400px';
                chatInterface.style.height = chatInterface.dataset.prevHeight || '600px';
            }
        });

        // Add resize functionality
        let isResizing = false;
        let originalWidth;
        let originalHeight;
        let originalX;
        let originalY;

        chatInterface.addEventListener('mousedown', (e) => {
            // Check if clicking on the bottom-right corner (resize handle)
            const rect = chatInterface.getBoundingClientRect();
            const isClickOnResizeHandle =
                e.clientX > rect.right - 20 &&
                e.clientY > rect.bottom - 20;

            if (isClickOnResizeHandle && !isExpanded) {
                isResizing = true;
                originalWidth = chatInterface.offsetWidth;
                originalHeight = chatInterface.offsetHeight;
                originalX = e.clientX;
                originalY = e.clientY;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const width = originalWidth + (e.clientX - originalX);
                const height = originalHeight + (e.clientY - originalY);

                // Apply minimum dimensions
                chatInterface.style.width = `${Math.max(400, width)}px`;
                chatInterface.style.height = `${Math.max(600, height)}px`;

                // Prevent text selection during resize
                e.preventDefault();
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
        });

        // Update close chat function to reset expanded state
        function closeChatInterface() {
            isExpanded = false;
            chatInterface.classList.remove('expanded', 'visible');
            expandChatButton.querySelector('.material-icons').textContent = 'fullscreen';
            setTimeout(() => {
                chatInterface.style.display = 'none';
            }, 300);
            chatButton.style.display = 'flex';
        }

        // ============ Citations Drawer Functionality ============
        const citationsButton = document.getElementById('citationsButton');
        const citationsDrawer = document.getElementById('citationsDrawer');
        const closeCitationsButton = document.getElementById('closeCitationsButton');
        const citationsList = document.getElementById('citationsList');
        const citationsStatus = document.getElementById('citationsStatus');
        const citationsCount = document.getElementById('citationsCount');
        const citationsSearch = document.getElementById('citationsSearch');
        const citationsTypeFilter = document.getElementById('citationsTypeFilter');
        const citationsYearFilter = document.getElementById('citationsYearFilter');
        const citationsFullTextOnly = document.getElementById('citationsFullTextOnly');

        let citationsCache = [];
        let renderedCitations = [];

        function getCitationType(c) {
            if (c.doi) return 'doi';
            if (c.arxiv_id) return 'arxiv';
            return 'title';
        }

        function populateCitationsYearFilter(citations) {
            const years = Array.from(new Set((citations || []).map(c => c.year).filter(Boolean))).sort((a, b) => b - a);
            const current = citationsYearFilter.value || 'all';
            citationsYearFilter.innerHTML = `<option value="all">All years</option>` + years.map(y => `<option value="${y}">${y}</option>`).join('');
            citationsYearFilter.value = years.includes(parseInt(current)) ? current : 'all';
        }

        function applyCitationsFilters() {
            const q = (citationsSearch.value || '').trim().toLowerCase();
            const type = citationsTypeFilter.value || 'all';
            const year = citationsYearFilter.value || 'all';
            const fullOnly = !!citationsFullTextOnly.checked;

            let filtered = (citationsCache || []).slice();
            if (type !== 'all') filtered = filtered.filter(c => getCitationType(c) === type);
            if (year !== 'all') filtered = filtered.filter(c => String(c.year || '') === String(year));
            if (fullOnly) filtered = filtered.filter(c => !!c.hasFullText);
            if (q) {
                filtered = filtered.filter(c => {
                    const hay = [
                        c.title, c.authors, c.abstract, c.doi, c.arxiv_id, c.raw_text
                    ].filter(Boolean).join(' ').toLowerCase();
                    return hay.includes(q);
                });
            }

            renderCitations(filtered, (citationsCache || []).length);
        }

        citationsSearch.addEventListener('input', () => applyCitationsFilters());
        citationsTypeFilter.addEventListener('change', () => applyCitationsFilters());
        citationsYearFilter.addEventListener('change', () => applyCitationsFilters());
        citationsFullTextOnly.addEventListener('change', () => applyCitationsFilters());

        // Toggle citations drawer
        citationsButton.addEventListener('click', () => {
            citationsDrawer.classList.add('visible');
            if (currentConversationId) {
                loadCitations(currentConversationId);
            }
        });

        closeCitationsButton.addEventListener('click', () => {
            citationsDrawer.classList.remove('visible');
        });

        // Close drawer when clicking outside
        document.addEventListener('click', (e) => {
            if (citationsDrawer.classList.contains('visible') &&
                !citationsDrawer.contains(e.target) &&
                !citationsButton.contains(e.target)) {
                citationsDrawer.classList.remove('visible');
            }
        });

        // Fetch citations from API
        async function loadCitations(uploadId) {
            citationsList.innerHTML = `
                <div class="citations-loading">
                    <div class="spinner"></div>
                    <p>Loading references...</p>
                </div>
            `;
            citationsStatus.textContent = '';

            try {
                const response = await fetch(`/citations/${uploadId}`);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                citationsCache = data.citations || [];
                populateCitationsYearFilter(citationsCache);
                applyCitationsFilters();
            } catch (error) {
                console.error('Error loading citations:', error);
                citationsList.innerHTML = `
                    <div class="citations-empty">
                        <i class="material-icons">error_outline</i>
                        <p>Failed to load references</p>
                        <p style="font-size: 12px;">${error.message}</p>
                    </div>
                `;
            }
        }

        // Render citations in the drawer
        function renderCitations(citations, totalCount) {
            renderedCitations = citations || [];
            // Update count badge
            citationsCount.textContent = totalCount > 0 ? totalCount : '';

            if (!citations || citations.length === 0) {
                citationsList.innerHTML = `
                    <div class="citations-empty">
                        <i class="material-icons">library_books</i>
                        <p>No references found</p>
                        <p style="font-size: 12px;">References will appear here once extracted from the paper.</p>
                    </div>
                `;
                citationsStatus.textContent = totalCount ? 'No references match your filters.' : 'No references extracted yet.';
                return;
            }

            const withFullText = (citationsCache || []).filter(c => c.hasFullText).length;
            const filteredCount = citations.length;
            citationsStatus.textContent = `${filteredCount} shown of ${totalCount}. ${withFullText} total with accessible full text.`;

            citationsList.innerHTML = citations.map((citation, index) => {
                const hasTitle = citation.title && citation.title !== citation.doi && citation.title !== citation.arxiv_id;
                const titleDisplay = hasTitle ? citation.title : `Reference ${index + 1}`;
                const titleHtml = citation.url
                    ? `<a href="${citation.url}" target="_blank">${escapeHtml(titleDisplay)}</a>`
                    : escapeHtml(titleDisplay);

                // Build identifier line (DOI or arXiv ID)
                let identifierHtml = '';
                if (citation.doi) {
                    identifierHtml = `<div class="citation-doi">DOI: <a href="https://doi.org/${escapeHtml(citation.doi)}" target="_blank">${escapeHtml(citation.doi)}</a></div>`;
                } else if (citation.arxiv_id) {
                    identifierHtml = `<div class="citation-doi">arXiv: <a href="https://arxiv.org/abs/${escapeHtml(citation.arxiv_id)}" target="_blank">${escapeHtml(citation.arxiv_id)}</a></div>`;
                }

                // Year display
                const yearHtml = citation.year ? `<span class="citation-year">(${citation.year})</span>` : '';

                return `
                    <div class="citation-card ${citation.hasFullText ? 'has-fulltext' : ''}">
                        <div class="citation-title">${titleHtml} ${yearHtml}</div>
                        ${citation.authors ? `<div class="citation-authors">${escapeHtml(citation.authors)}</div>` : ''}
                        ${identifierHtml}
                        ${citation.abstract ? `
                            <div class="citation-abstract truncated" id="abstract-${index}">${escapeHtml(citation.abstract)}</div>
                            <button class="citation-abstract-toggle" onclick="toggleAbstract(${index})">Show more</button>
                        ` : ''}
                        <div style="display:flex; gap: 8px; margin-top: 10px;">
                            <button class="secondary" style="flex:1;" onclick="addCitationToChat(${index});">
                                <i class="material-icons">chat</i>
                                Add to Chat
                            </button>
                            <button style="flex:1;" onclick="summarizeCitation(${index});">
                                <i class="material-icons">summarize</i>
                                Summarize
                            </button>
                        </div>
                        ${citation.hasFullText ? '<span class="citation-badge">Full text available</span>' : ''}
                    </div>
                `;
            }).join('');
        }

        // Toggle abstract expansion
        function toggleAbstract(index) {
            const abstract = document.getElementById(`abstract-${index}`);
            const button = abstract.nextElementSibling;
            if (abstract.classList.contains('truncated')) {
                abstract.classList.remove('truncated');
                button.textContent = 'Show less';
            } else {
                abstract.classList.add('truncated');
                button.textContent = 'Show more';
            }
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function addCitationToChat(index) {
            const citation = renderedCitations[index];
            if (!citation) return;

            // Open chat if not already open
            if (!chatInterface.classList.contains('visible')) {
                chatButton.click();
            }

            const parts = [];
            parts.push(`Citation: ${citation.title || citation.identifier || 'Untitled'}`);
            if (citation.authors) parts.push(`Authors: ${citation.authors}`);
            if (citation.year) parts.push(`Year: ${citation.year}`);
            if (citation.doi) parts.push(`DOI: ${citation.doi}`);
            if (citation.arxiv_id) parts.push(`arXiv: ${citation.arxiv_id}`);
            if (citation.url) parts.push(`URL: ${citation.url}`);
            if (citation.abstract) parts.push(`Abstract: ${citation.abstract}`);
            const msg = parts.join('\n');
            addMessageToChat('system', msg);
        }

        async function summarizeCitation(index) {
            const citation = renderedCitations[index];
            if (!citation || !currentConversationId) return;

            const provider = getSelectedProvider();

            const modal = document.createElement('div');
            modal.className = 'ai-response-modal';
            modal.innerHTML = `
                <h3>
                    <i class="material-icons">summarize</i>
                    Citation Summary
                </h3>
                <div class="content" id="streamingCitationSummary"></div>
                <div class="actions">
                    <button onclick="this.closest('.ai-response-modal').remove()">
                        <i class="material-icons">close</i>
                        Close
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            const contentDiv = modal.querySelector('#streamingCitationSummary');

            const requestData = {
                provider,
                uploadId: currentConversationId,
                doi: citation.doi || '',
                arxiv_id: citation.arxiv_id || '',
                title: citation.title || ''
            };

            let raw = '';
            let scheduled = false;
            const render = () => {
                scheduled = false;
                contentDiv.innerHTML = renderMarkdown(raw);
            };

            try {
                await fetchSSE('/summarize-citation/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                }, {
                    onToken: (tok) => {
                        raw += tok;
                        if (!scheduled) {
                            scheduled = true;
                            requestAnimationFrame(render);
                        }
                    },
                    onDone: (fullText) => {
                        raw = fullText || raw;
                        render();
                    },
                    onError: (err) => {
                        contentDiv.textContent = 'Error: ' + err;
                    }
                });
            } catch (e) {
                contentDiv.textContent = 'Error: ' + (e.message || String(e));
            }
        }

        // Update loadConversation to show/hide citations button
        const originalLoadConversation = loadConversation;
        loadConversation = function (id) {
            originalLoadConversation(id);
            // Show citations button and update count
            document.getElementById('citationsButton').classList.remove('no-paper');
            // Pre-fetch citations count
            fetch(`/citations/${id}`)
                .then(r => r.json())
                .then(data => {
                    if (data.count !== undefined) {
                        citationsCount.textContent = data.count > 0 ? data.count : '';
                    }
                })
                .catch(() => { });
        };

        // Update deleteConversation to hide citations
        const originalDeleteConversation = deleteConversation;
        deleteConversation = function (id) {
            originalDeleteConversation(id);
            if (!currentConversationId) {
                document.getElementById('citationsButton').classList.add('no-paper');
                citationsDrawer.classList.remove('visible');
                citationsCount.textContent = '';
            }
        };
    </script>
</body>

</html>